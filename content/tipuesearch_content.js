var tipuesearch = {"pages": [{'title': 'About', 'text': '第 1 組成員: \xa0?\xa0 \xa0?\xa0 \xa0?\xa0 \xa0 \xa0\xa0 40523120 倉儲 \xa0 | \xa0 40523120 網站 \xa0 林昱秀\xa0 \xa0 40723102 倉儲 \xa0 | \xa0 40723102 網站 李正揚\xa0 \xa0 40723110 倉儲 \xa0 | \xa0 40723110 網站 李冠廷\xa0\xa0 \xa0\xa0 40723112 倉儲 \xa0 | \xa0 40723112 網站 林于哲\xa0 \xa0 40723115 倉儲 \xa0 | \xa0 40723115 網站 林靖浩\xa0 \xa0 40723120 倉儲 \xa0 | \xa0 40723120 網站 許嘉紘\xa0 \xa0 40723127 倉儲 \xa0 | \xa0 40723127 網站 彭少鍚\xa0 \xa0 40723136 倉儲 \xa0 | \xa0 40723136 網站 黃譯賢\xa0 \xa0 40723140 倉儲 \xa0 | \xa0 40723140 網站 詹益任\xa0 \xa0 40723143 倉儲 \xa0 | \xa0 40723143 網站 劉敬中\xa0 \xa0 40723146 倉儲 \xa0 | \xa0 40723146 網站 鄭博鴻\xa0 \xa0 40723148 倉儲 \xa0 | \xa0 40723148 網站 \n', 'tags': '', 'url': 'About.html'}, {'title': '每周任務', 'text': '', 'tags': '', 'url': '每周任務.html'}, {'title': 'Week10', 'text': '啟動分組程序 \n 分配組員工作 \n ---------------------------------------------- \n 1 . 以分組協同方式整理教科書內容 \n 2 .\xa0 處理 content.htm, reveal 簡報以及 pelican 網誌 markdown 中的改版衝突 \n 3 . NX及SolveSpace 繪圖\xa0 \n 4 . V-rep 與 Webots Tutorial, 分別利用 Solvespace 與 NX 建立零組件轉入 \n \n', 'tags': '', 'url': 'Week10.html'}, {'title': 'Week12 應力分析', 'text': '1.NX 零組件繪圖 \n 2.Webots 與 V-rep Tutorial \n ---------------------------------------------------- \n 1 . 分別用 Solvespace\xa0 \xa0和\xa0 NX 建立零組件，錄製繪圖過程並建構出零組件後與V-REP、Webots組做 結合。 \n 2 .\xa0 NX繪圖者匯出零件後分析零件應力分析，再和Webots的應力分析做比較，得出差異性。 \n', 'tags': '', 'url': 'Week12 應力分析.html'}, {'title': '模擬', 'text': '', 'tags': '', 'url': '模擬.html'}, {'title': 'Webots', 'text': 'Webots的開發始於1996年12月 在洛桑 的 瑞士聯邦技術學院（EPFL）， 當時Olivier Michel被Jean-Daniel Nicoud教授聘為博士後研究員。 \n 該公司成立於1998年，是從EPFL的MicroComputing and Interface Lab（LAMI）衍生出來的。 Cyberbotics的最初導師包括Jean-Daniel Nicoud教授，Francesco Mondada教授和Takashi Gomi博士。 \n 從一開始，Webots就被行業（Sony Corp.）和大學用於研究和教育目的。 \n 在2018年12月，Webots已成為根據 Apache 2.0許可 條款發行的免費開源軟件 \xa0 。 \n 如今，Webots已在全球成千上萬的組織中使用，包括行業和學術界。 \n Webots_2019b_rev1.7z \xa0 \n Webots 啟動條件: \n 1. 將start_mdecourse.bat 中加入執行路徑: \n set path_webots=%Disk%:\\Webots_2019b_rev1\\msys64\\mingw64\\bin;%Disk%:\\Webots_2019b_rev1\\msys64\\usr\\bin \n 並在 y:\\ 根目錄建立 start_webots.bat, 內容為: \n \n start Y:\\Webots_2019b_rev1\\msys64\\mingw64\\bin\\webots.exe \n \n 隨身程式系統納入上述兩個條件後, 可以直接在命令列輸入 start_webots.bat 啟動 \n \n', 'tags': '', 'url': 'Webots.html'}, {'title': 'Webots Tutorial', 'text': "Tutorial 1. \n \n 機器人以其最大速度移動一段時間，然後在輪子旋轉10弧度後停止 \n from controller import Robot, Motor\n\nTIME_STEP = 64\n\n# create the Robot instance.\nrobot = Robot()\n\n# get the motor devices\nleftMotor = robot.getMotor('left wheel motor')\nrightMotor = robot.getMotor('right wheel motor')\n# set the target position of the motors\nleftMotor.setPosition(10.0)\nrightMotor.setPosition(10.0)\n\nwhile robot.step(TIME_STEP) != -1:\n   pass \n 輪子將以每秒1弧度的速度旋轉 \n from controller import Robot, Motor\n\nTIME_STEP = 64\n\nMAX_SPEED = 6.28\n\n# create the Robot instance.\nrobot = Robot()\n\n# get a handler to the motors and set target position to infinity (speed control)\nleftMotor = robot.getMotor('left wheel motor')\nrightMotor = robot.getMotor('right wheel motor')\nleftMotor.setPosition(float('inf'))\nrightMotor.setPosition(float('inf'))\n\n# set up the motor speeds at 10% of the MAX_SPEED.\nleftMotor.setVelocity(0.1 * MAX_SPEED)\nrightMotor.setVelocity(0.1 * MAX_SPEED)\n\nwhile robot.step(TIME_STEP) != -1:\n   pass \n \n", 'tags': '', 'url': 'Webots Tutorial.html'}, {'title': 'V-rep', 'text': 'solvespace 自走車繪製 \n \n Vrep導入練習 \n \n Vrep 動態相關設定練習 \n \n', 'tags': '', 'url': 'V-rep.html'}, {'title': '繪圖程式類別', 'text': '\n', 'tags': '', 'url': '繪圖程式類別.html'}, {'title': 'Inventor 2019', 'text': 'CHAPTER 1 –History \n \xa0 \xa0Inventor在1999年發表， Jay Tedeschi在AUTODESk工作了23年，創建了AUTODESK許多主要的工作軟體。在Inventor出現之前，AUTODESk有一個３Ｄ參數工具叫作Designer，該軟體後來發展為機械設計的工具。在當時 Jay Tedeschi認為ＳＯＬＩＷＯＲＫＳ是當時最先進的機械設計軟體，後來Jay Tedeschi的團隊把ＳＯＬＩＷＯＲＫＳ併購及整合到ＡＵＴＯＤＥＳＫ設計軟體中。 Jay Tedeschi有一套方法論設計INVENTOR，甚至是塑造了現在的Autodesk，他的團隊設計的軟體與以往的軟體相較之下，對中端用戶更為值觀，他們也試著讓INVENTOR的容量變得比過去的設計軟體還小。Inventor是第一個實現幾何設計的軟體，ineventor會將圖形數據與實際模型數據分開，實質上就是將零件的圖形和較複雜材料和幾何數據分開加載。在INVENTOR引入設計領域後，在所有工程工作流程中最具革命性的軟體。 多年來，INVENTOR也有許多的變化，但AUTODESK的設計絲路依舊保持不變。工程師們一直致力於讓軟體直觀易用，這是 Jay Tedeschi所堅定的概念。 \n', 'tags': '', 'url': 'Inventor 2019.html'}, {'title': '繪圖認證', 'text': '\n \n', 'tags': '', 'url': '繪圖認證.html'}, {'title': 'NX12', 'text': 'source :\xa0 NX-12-for-Engineering-Design.pdf  \n source :\xa0 NX-12-for-Engineering-Design.pdf \n', 'tags': '', 'url': 'NX12.html'}, {'title': 'CHAPTER 1 – INTRODUCTION', 'text': '\xa0 \xa0在全球競爭日益激烈的背景下，現代製造環境的特徵在於交付品種日益增多，並趨向於小批量和高質量的產品。 除非以高質量、低成本和在更短時間推出新產品，否則在全球競爭中生存是一件很難的事。隨著計算能力的巨大變化和用於設計和生產的軟件工具的廣泛可用性，工程師現在正在使用計算機輔助設計（CAD），計算機輔助製造（CAM）和計算機輔助工程（CAE）系統來自動化其設計和生產過程。 現在，這些技術每天都用於各種不同的工程任務。 以下是產品實現過程中如何使用CAD，CAM和CAE技術的簡要說明。 \n 1.1 PRODUCT REALIZATION PROCESS\xa0 \n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0產品實現過程可以大致分為兩個階段：設計和製造。 設計過程從識別新客戶需求和待改進的設計變量開始，這些營銷變量在獲得客戶反饋後由市場營銷人員進行識別。 一旦收集了相關的設計信息，就制定了設計規範。 根據相關設計信息進行可行性研究，並進行詳細設計和分析。 詳細設計包括設計概念化，預期產品圖紙，草圖和幾何建模。 分析包括應力分析，干涉檢查，運動學分析，質量特性計算和公差分析以及設計優化。 從這些活動中獲得的結果的質量與分析的質量以及進行分析的工具直接相關。 \n 製造過程始於從生產計劃開始的車間活動，該活動使用設計過程圖並以實際產品結束。 流程計劃包括生產計劃，材料採購和機器選擇等活動。 在生產過程的各個階段，需要完成各種任務，例如購買新工具，NC編程和質量檢查。 流程計劃包括對產品製造中使用的所有流程的計劃。 通過質量控制檢查的零件將經過功能測試，包裝，標記和運送給客戶。 \n \n \xa0 \xa0 \xa0 Product Realization Process (Mastering CAD/CAM, by Ibrahim Zeid, McGraw Hill, 2005). \n \n 1.2 BRIEF HISTORY OF CAD/CAM DEVELOPMENT \xa0 \n \n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0當前的CAD / CAM技術的起源可以追溯到文明古代，當時古埃及的工程師意識到了圖形通信的存在。現今的正交投影技術是在1800年代左右發明的。，CAD / CAM系統的真正開發始於1950年代。 CAD / CAM在上個世紀經歷了四個主要的發展階段。 1950年代被稱為交互式計算機圖形時代，而當時計算機的缺點使這個時代的發展放慢了腳步。在1950年代後期，開始了自動編程工具（APT）的開發。 \n \xa0 \xa0 \xa0 \xa0 \xa0 \xa01960年代是交互式計算機圖形學最關鍵的研究時期。伊万·薩瑟蘭（Ivan Sutherland）開發了一個畫板系統，該系統演示了在陰極射線管（CRT）上交互式創建圖形和對象替換的可能性。 CAD一詞開始出現，“設計”一詞超越了基本的製圖概念。 \n \xa0 \xa0 \xa0 \xa0 \xa0 在1970年代，過去十年中計算機圖形學的研究工作開始富有成果，工業，政府和學術界都意識到了交互式計算機圖形學在提高生產率方面的潛力。 1970年代被譽為計算機製圖的黃金時代和專用儀器設計應用程序的開始。國家計算機圖形協會 成立 （NCGA），並啟動了初始圖形交換規範（IGES）。 \n \xa0 \xa0 \xa0 \xa0 \xa0 在1980年代，新的理論和算法得到了發展，並且設計和製造的各種要素都得到了發展。主要的研究和開發重點是將CAD / CAM系統擴展到三維幾何設計之外，並提供更多的工程應用。 \n \xa0 \xa0 \xa0 \xa0 \xa0 目前，CAD / CAM的開發側重於設計和製造中各種元素的高效、快速集成和自動化，以及新算法的開發。 有許多可用於直接使用的商業CAD / CAM軟件包，它們非常易於使用並且對外的態度非常友好。 \n 以下是當前市場中的一些商業軟件包。 \n ■\xa0 Solid Edge，AutoCAD，Inventor和TurboCAD是一些負擔得起的CAD軟件系統。 \n ■\xa0 NX，Pro-E，CATIA和SolidWorks是高端建模和設計軟件系統，它們成本更高但功能更強大。 這些軟件系統還具有計算機輔助的製造和工程分析功能。 ■\xa0 Onshape和Fusion 360是基於雲的CAD軟件，可通過用戶的瀏覽器提供CAD功能。 \n ■\xa0 ANSYS，ABAQUS，NASTRAN和COMSOL是主要用於CAE的軟件包。 \n \n 1.3 DEFINITION OF CAD/CAM/CAE\xa0 \n \xa0 \n 1.3.1 Computer Aided Design – CAD\xa0 \n \xa0 \xa0 \xa0 \xa0 \xa0 CAD是與使用計算機系統來協助設計的「創建，修改，分析和優化有關的技術」。 任何體現計算機圖形的計算機程序和在設計過程中有助於工程功能的應用程序都可以歸類為CAD軟件。 \n \xa0 \xa0 \xa0 \xa0 \xa0 CAD的最基本作用是定義設計的幾何形狀-機械零件，產品組裝，建築結構，電子電路，建築物佈局等。CAD系統的最大好處是可以節省大量時間和精力， 減少因每次需要重新定義設計的幾何形狀而導致的錯誤。 \n Computer Aided Manufacturing – CAM \n CAM技術涉及計算機系統，該系統通過與工廠生產資源的計算機接口來計劃、管理和控制製造操作。  CAM最重要的領域之一是數控「（NC）」。 這是一種使用編程指令來控制機床的技術，該機床將切削，銑削，磨削，沖壓或將原料製成成品。 CAM的另一個重要功能是在機器人編程中。 流程計劃也是計算機自動化的目標。 \n Computer Aided Engineering – CAE \n CAE技術使用計算機系統來分析CAD創建的產品的功能，從而使設計人員可以模擬和研究產品的性能，從而可以優化和優化設計。 \n CAE工具可用於許多不同類型的分析。 例如，運動學分析程序可用於確定機構中的運動路徑和連桿速度。 動態分析程序可用於確定複雜組件（例如汽車）中的載荷和位移。 最受歡迎的分析方法之一是使用有限元方法（FEM）。 該方法可用於確定應力，變形，傳熱，磁場分佈，流體流動和其他連續場問題，而這些問題通常很難用任何其他方法解決。 \n \n 1.4. SCOPE OF THIS TUTORIAL\xa0 \n \xa0 \xa0 \xa0 \xa0 \xa0 本教程是為有興趣學習如何使用NX 12設計機械零部件的學生和工程師編寫的。 學習使用NX 12對於學習如何使用其他CAD系統（例如PRO-E和CATIA）也將非常有價值。 本教程提供了學習NX 12的系統方法。 \n \xa0 \xa0 \xa0 \xa0 \xa0 第2章介紹了NX 12的基本知識，從開始會議到通過練習基本功能（如打印，保存和退出）來熟悉NX 12佈局。它還簡要介紹了坐標系，圖層，各種工具箱和其他重要命令，這些將在後面的章節中使用。 \xa0 \xa0 \xa0 \xa0 \xa0 第3章介紹了素描的概念。它描述瞭如何創建草圖以及給出幾何和尺寸約束。本章非常重要，因為當今的組件的幾何形狀非常複雜，並且僅憑基本特徵很難建模。 零件的實際設計和建模始於第4章。它描述了不同的特徵，例如參考特徵，後掠特徵和原始特徵，以及這些特徵如何用於創建設計。對特徵執行各種特徵操作。 \xa0 \xa0 \xa0 \xa0 \xa0 您將在第5章中學習如何從零件模型創建圖形。在本章中，我們將演示如何通過添加視圖，標註零件圖形的尺寸以及修改圖形中的各種屬性（例如文本大小，箭頭大小）來創建圖形。和寬容。 \xa0 \xa0 \xa0 \xa0 \xa0 第6章介紹了裝配建模的概念及其術語。它描述了TopDown建模和Bottom-Up建模。我們將使用自下而上的建模方法將組件組裝到產品中。 \xa0 \xa0 \xa0 \xa0 \xa0 第7章介紹了自由格式建模。將演示建模曲線和平滑表面的方法。 \xa0 \xa0 \xa0 \xa0 \xa0 第8章簡要介紹了NX 12中用於有限元分析的設計仿真 \n \xa0 \xa0 \xa0 \xa0 \xa0 第9章是將設計的模型實施到加工環境中進行加工的實時經驗。 本章介紹刀具路徑的生成，驗證和仿真，以創建CNC（計算機數字代碼），以從多軸甚至先進的CNC機床生產設計零件。 \n \xa0 \xa0 \xa0 \xa0 \xa0 每章中使用的示例和練習題經過精心設計，最終將在本章中進行匯總。 由於這一獨特功能，您應該保存在每一章中創建的所有模型。 \n \xa0NX歷史 \n \xa0 NX源自於美國麥道航太公司，近30年的資深CAD / CAM / CAE系統，再加上西門子在系統與設備，工程上的經驗與能力提供在加工與產品開發設計上更多的資源與整合。 \n 在CAM加工上智慧模型（MasterModel）的概念，至少包含3DCAD模型，與NC路徑的完整關聯性，並替換數據大小以及刀具路徑的管理，在高速切銷加工上提供穩定可靠與加工品質，同時針對複合銑削加工的領域提供完整的解決方案。 \n NX優點 \xa0 NX讓客戶增加新產品數量，減少30％以上的開發時間，縮短70％以上的設計分析重複作業，並減少高達90％的電腦數控（CNC）編程時間。 \n CAD   \xa0• 從零件設計資料輸入開始，通常是3D CAD模型，某些情況下也可能是2D圖面。通常會需要用到3D CAD軟體以準備或調整零件設計模型，進行後續的NC編程操作。 \n CAM   \xa0• NX CAM包含NC編程，後處理及工具機模擬。 \xa0• 功能完備的套件Siemens是進階工具機控制器技術及驅動設備領域的公認領導廠商。 \n NX CAD / CAM一體化的優勢 \xa0• 3D零件建模準備NX最新的CAD技術能夠NC程序設計師迅速準備零件模型，包括協力廠商的CAD模型。只要利用同步建模技術，就可以直接編輯零件模型，準備讓零件進入NC編程。 \n \xa0• NX提供一組專門的CAD功能，讓NC程序設計師能夠在建立NC操作之前快速進行分析。 \n \xa0•\xa0 建模，組立件與製圖-NX提供了當今市場上最強大的CAD功能組合。這些功能已替換NX CAM之中，且有需要的NC程序設計師使用建立零件，坯件形狀，夾治具或工具機模型以進行模擬 。 CAD-CAM-CNC流程鏈 \n \n \n', 'tags': '', 'url': 'CHAPTER 1 – INTRODUCTION.html'}, {'title': 'CHAPTER 2 – GETTING STARTED', 'text': '2.1啟動NX12 \n 2.1.1啟動NX12 \n 2.1.2 打開新的文件 \n a.點擊屏幕頂部的“新建”按鈕 \n b.瀏覽屏幕左上方的“文件”下拉菜單，然後單擊“新建”  c.按<Ctrl> + N \n 2.1.3 打開零件文件 \n a.單擊屏幕頂部的\xa0Open\xa0 或Open a Recent Part\xa0打開最近的零件按鈕 b. 瀏覽屏幕左上方的“File\xa0”下拉菜單，然後單擊“Open” c. 按<Ctrl> + O \n  這個快捷將顯示“打開零件文件”對話框。您可以在窗口右側看到文件的預覽。 您可以通過取消選中預覽按鈕前面的框來禁用預覽 d. 單擊Cancel退出窗口 2.2列印，儲存和關閉文件 \n \xa02.2.1打印NX 12圖像要從當前顯示器打印圖像 \n ➢點擊文件→打印 在這裡，您可以選擇要使用的影印機，或者指定要影印的份數，紙張尺寸等。您還可以為所有三個尺寸選擇比例。您還可以通過尺寸 輸出拖動菜單來選擇打印方法，即線框，實體模型， \n ➢點擊取消退出窗口 \n 2.2.2保存零件文件 必須經常儲存工作。 如果由於某些原因NX 12關閉並且未保存零件，則所有工作將丟失。 要保存零件文件， ➢單擊文件→保存，有五個選項可保存文件：保存：此選項將在創建零件文件時使用與先前相同的名稱將零件保存在屏幕上。 \n .a.僅保存工作零件：此選項僅將活動零件保存在屏幕上。 b.另存為：此選項允許您使用其他名稱和/或類型將零件保存在屏幕上。 默認類型是.prt。 但是，您可以將文件另存為IGES（.igs），STEP 203（.stp），STEP 214（.step），AutoCAD DXF（.dxf），AutoCAD DWG（.dwg），CATIA模型（.model）和CATIA V5（.catpart）。 c.全部保存：此選項將保存所有打開的零件文件及其現有名稱。 \n d.保存書籤：此選項會將屏幕上截圖和當前模型的上下文保存為.JPEG文件和書籤。 \n 2.2.3關閉零件文件 \n 您可以選擇關閉屏幕上可見的零件，方法是： ➢單擊文件→關閉。如果關閉文件，該文件將從工作存儲器中清除，所有未保存的更改將丟失。 因此，請記住選擇“保存並關閉”，“另存為並關閉”，“保存所有並關閉”或“保存所有並退出”。 對於前三個選項，將關閉所選的零件或所有零件，但NX 12會話將繼續運行。 \n 2.2.4退出NX 12 \n ➢單擊文件→退出 \xa0 如果您打開了文件並在未保存的情況下對其進行了更改，則該消息將詢問您是否確實要退出。 ➢選擇否，保存文件，然後退出 2.3\xa0 NX 12介面 通過使用不同的圖標，NX 12的用戶界面變得非常簡單。大多數命令可以通過在屏幕上導航鼠標並單擊圖標來執行。鍵盤輸入主要限於輸入值和命名文件。 \n 2.3.1鼠標功能 \n 2.3.1.1鼠標左鍵（MB1） \n 鼠標左鍵在NX中稱為鼠標鍵1（MB1），用於在圖形屏幕上選擇圖標，菜單和其他實體。在任何功能上雙擊MB1都會自動打開“編輯對話框”。單擊對像上的MB1，使用戶可以快速訪問下面顯示的幾個選項。這些選項將在下一章中討論。 \n 2.3.1.2鼠標中鍵（MB2） \n 鼠標中鍵（MB2）或滾動按鈕用於通過按住，拖動來旋轉對象。模型也可以繞單個軸旋轉。要繞水平於屏幕的軸旋轉，請將鼠標指針放在圖形屏幕的右邊緣附近並旋轉。同樣，對於垂直軸和垂直於屏幕的軸，分別單擊屏幕的底部邊緣和頂部邊緣並旋轉。如果在同一位置連續按住MB2幾秒鐘，它將固定旋轉點（出現橙色圓圈符號），並且可以在對象周圍拖動以查看。 如果是滾動按鈕，則可以通過滾動對象來放大和縮小。如果打開了任何彈出窗口或對話框，則單擊MB2還將執行OK命令。 \n \xa02.3.1.3鼠標右鍵（MB3） \n MB3或鼠標右鍵用於訪問用戶界面彈出菜單。您可以訪問隨後彈出的選項，具體取決於選擇模式和應用程序。下圖顯示在Sketch Application中。選擇功能後單擊MB3將提供與該功能相關的選項（對象/操作菜單）。單擊MB3並按住該按鈕將在功能周圍顯示一組圖標。這些圖標帶有可應用於功能的可能命令。 \n 2.3.1.4按鈕組合放大/縮小： \n ➢同時按住MB1和MB2並拖動 要么 ➢按住鍵盤上的<Ctrl>按鈕，然後按住並拖動MB2 要么 \xa0 泛： ➢同時按住MB2和MB3並拖動 要么 ➢按住鍵盤上的<Shift>按鈕並按住MB2 \xa0 菜單快捷方式： ➢按住<Ctrl> + <Shift>和MB1，MB2和MB3分別查看功能，直接草圖和同步建模組的快捷方式 \xa0 2.3.2NX 12介面 \n 2.3.3幾何選擇 \n 您可以過濾選擇方法，以便於在繁雜中輕鬆選擇幾何。 此外，您可以根據所選實體執行NX 12智能提供的任何功能操作選項。 項目的選擇可以基於實體的程度，例如，幾何實體，特徵和組件的選擇。 可以通過選擇選擇工具欄中的圖標之一來選擇選擇方法。 \n 2.3.3.1特徵選擇 \n 單擊任何圖標，可以選擇零件文件中的特徵。 它不會選擇諸如邊，面等基本實體。所選的特徵還可以根據需要應用於零件或整個裝配體。除此之外，可以通過在下拉菜單中選擇所需選項之一來進一步縮小特徵的過濾範圍，如圖所示。 例如，選擇“曲線”將僅在屏幕上突出顯示曲線。 默認值為“\xa0No Selection Filter無選擇過濾器”。 \n 2.3.3.2常規對象選擇 \n \xa0將鼠標光標導航到更靠近實體的位置，直到用洋紅色突出顯示該實體，然後單擊鼠標左鍵以選擇任何幾何實體，特徵或組件。 如果要選擇隱藏在顯示的幾何圖形後面的實體，請將鼠標光標放在屏幕上的該區域附近，以使光標球佔據投影在屏幕上的隱藏幾何圖形的一部分。幾秒鐘後，球形光標變為加號，如圖所示。單擊鼠標左鍵（MB1），將顯示“選擇確認”對話框，如下圖所示。此QuickPick菜單包含在光標球內捕獲的實體的列表。實體按其程度的升序排列。例如，為邊和頂點分配的數字較小，而為實體面分配的數字較大。通過在顯示的數字上移動光標，NX 12將在屏幕上以洋紅色突出顯示相應的實體。 \n \n \n 2.3.4用戶偏好 \n 2.3.5應用 \n 可以使用位於主窗口左上角的“文件”選項或功能區欄上方的“應用程序”選項卡來打開應用程序。 您可以選擇要運行的應用程序類型。 例如，您可以選擇“建模”，“製圖”，“裝配”等 \n 2.4圖層 \n “圖層”提供了一種永久的方式來組織和管理文件中對象的可見性和選擇性。 \n 2.4.1圖層控制 \n 使用NX 12，您可以使用“圖層”控制對像是可見還是可選。圖層是NX 12中所有對象必須具有的系統定義的屬性，例如顏色，字體和寬度。 NX 12中有256個可用圖層，其中一層始終是工作圖層。 256層中的任何一層都可以分配給四個狀態類別之一。 .a.工作 \xa0b.可選 \xa0c.僅可見 \xa0d.不可見 工作圖層是在其上創建對象的圖層，並且在保留工作 圖 層的同時始終可見且可以選擇。啟動新零件文件時，第1層是默認的工作 圖 層。當工作 圖 層更改為另一種類型的 圖 層時，先前的工作層將自動變為“可選”，然後可以分配為“僅可見”或“不可見”狀態。 可以在一 圖 層上的對象數量不受限制。您可以自由選擇要在其上創建對象的任何 圖 層以及該層的狀態。 要將狀態分配給一個或多個圖層， ➢選擇查看→圖層設置 但是，應該注意，關於 圖 層的標準的使用將有利於保持文件之間的一致性。 \n 2.4.2分層命令 \n 我們將按照簡單的步驟來練習“圖層”中的命令。首先，我們將通過以下方法創建兩個對象（實體）。實體建模的細節將在下一章中討論。我們在此處繪製的實體僅在本章中用於實踐。 ➢選擇文件→新建 命名文件並選擇要在其中保存文件的文件夾。確保在下拉菜單中選擇以毫米為單位。選擇文件類型作為模型 ➢選擇菜單→插入→設計特徵→圓錐體➢在類型下選擇直徑和高度 ➢點擊確定 ➢右鍵單擊屏幕，然後選擇“ Orient View”→“ Trimetric” ➢右鍵單擊屏幕，然後選擇“渲染樣式”→“陰影” 您將能夠看到類似於右圖的實心圓錐。 現在讓我們練習一些圖層命令。 ➢選擇查看→移動到圖層 系統將要求您選擇一個對象 ➢將光標移到圓錐上並單擊，使其突出顯示 ➢點擊確定 ➢在窗口頂部的“目標層”或“類別”空間中，輸入25，然後單擊“確定”。 圓錐現在已經到達第25層。在第1層中不再可見。 ➢要查看圓錐體，請單擊查看→圖層設置 ➢您可以看到第25層有對象，而默認的工作第1層沒有對象。 錐體將再次出現在屏幕上。保存該文件，因為我們將在本教程的後面部分中使用它。 \n 2.5座標系統 \n 2.6 工具列表 \n', 'tags': '', 'url': 'CHAPTER 2 – GETTING STARTED.html'}, {'title': 'CHAPTER 3 – TWO DIMENSIONAL SKETCHING', 'text': '第3章-二維草圖 \n 在本章中，您將學習如何在NX 12中創建和編輯草圖。您可以在“建模中的平面”應用程序中直接創建草圖。在大多數情況下，建模從2D草圖開始，然後拉伸，旋轉或掃掠草圖以創建實體。通過繪製草圖可以輕鬆地繪製許多本來很難建模的複雜形狀。在本章中，我們將看到一些草圖繪製概念，然後繼續對某些零件進行草圖繪製和建模。 \n 3.1概述 \n NX 12草圖是一組命名的曲線，這些曲線連接在一個字符串中，掃描後形成實體。草圖表示該零件的外邊界。曲線在草繪器中的平面上創建。首先，這些曲線的繪製沒有任何確切的尺寸。然後，應用尺寸約束和幾何約束來完全約束草圖。這些將在本章後面詳細討論。 繪製完成後，可以使用多種方法來生成3D零件： \n •草圖可以旋轉 \n •草圖可以拉伸 \xa0 •草圖可以沿參考線（線）進行掃掠： \xa0 \xa0 從草圖創建的特徵與之關聯；即，如果草圖發生變化，特徵也會發生變化。 \n 使用草圖創建零件的優點是： •用於創建輪廓輪廓的曲線非常靈活，可用於建立模型在非正規形狀上。 •曲線是參數化的，因此具有關聯性，可以輕鬆更改或刪除它們。 •如果更改了繪製草圖的平面，則草圖也會相應更改。 •當您想要控制功能的輪廓時，草圖很有用，尤其是將來可能需要更改時。草圖可以快速，輕鬆地進行編輯。 \n \n 3.2繪製草圖的情形 \n \n 在NX 12中，可以使用兩種方法創建草圖。第一種方法在當前環境和應用程序中創建Sketch。 ➢選擇菜單→插入→草圖 在另一種方法中，您可以使用 ➢在主工具欄中選擇草圖 無論哪種情況，都會彈出一個對話框，要求您定義草圖平面。屏幕將顯示草圖選項。您可以選擇“草繪平面”，草繪方向和草繪平面類型。使用“創建草圖”對話框創建草圖時，可以通過單擊所示的坐標係來選擇可以在其上創建草圖的平面。這將突出顯示您選擇的平面。選擇的默認平面為XC-YC。但是，您可以選擇在另一平面上繪製草圖。如果事先在模型中創建了任何實體特徵，則任何平面都可以用作草繪平面。 ➢選擇XC-YC平面並單擊確定 將顯示草圖平面，並標記X-Y方向。 \n \n 3.3草圖曲線工具欄 該工具欄包含用於創建常用類型的曲線和样條曲線，編輯，擴展，修剪，圓角等的圖標。每種類型的曲線都有不同的選擇方法和創建方法。 讓我們討論最常用的選項。 \n \xa0 輪廓 此選項會根據您在彈出工具欄中選擇的圖標創建直線和圓弧。 您可以通過使用坐標系或通過輸入線的長度和角度來拾取點。 \n \xa0 線 此選項將選擇性地僅創建直線。 \n \xa0 弧 此選項通過兩種方法之一創建弧。 第一個選項創建具有三個連續點的弧。 第二個選項創建具有中心點，半徑和後掠角的圓弧，或者創建具有起點和終點的圓弧。 \n \xa0 圈 創建圓類似於創建圓弧，不同之處在於，圓是封閉的。 \n 快速修剪 這將從曲線的交點修剪延伸的曲線。如果每個實體與另一個實體相交，則此選項通過拆分每個實體來讀取它們，並擦除所選部分。 \n 樣條(樣條函數)曲線 您可以創建具有極點或具有所需曲線度的點的基本樣條曲線。 \n \n 3.4約束工具欄 \n 所有曲線都是通過拾取點創建的。例如，一條直線有兩個點。在2D環境中，任何點都具有兩個自由度，一個沿X軸，另一個沿Y軸。點的數量取決於要創建的曲線的類型。因此，曲線實體的自由度數是其包含的點數的兩倍。這些自由度可以通過使用固定實體創建約束來消除。實際上，建議您通過直接或間接將實體與固定實體相關聯來刪除所有這些自由度（使草圖完全受約束）。可以通過提供尺寸或幾何屬性（如平行度，垂直度等）來完成。 在NX 12中，智能約束是自動應用的，即NX 12會解釋自動尺寸或幾何約束。您可以通過單擊“連續自動標註”來關閉此選項，如下所示。以下段落顯示瞭如何手動應用約束。 \n 尺寸約束 可以通過給尺寸賦予固定實體（例如軸，平面，坐標系或模型中創建的任何現有實體幾何形狀）來消除自由度。這些尺寸可以是線性，徑向，角度等。您可以在草繪過程中隨時通過雙擊尺寸來編輯尺寸值。 \n \xa0幾何約束 除了尺寸約束之外，還可以提供一些幾何約束以消除自由度。它們包括平行的，垂直的，共線的，同心的，水平的，垂直的，等長的，等等。該軟件能夠為所選實體找到可能的約束集。例如，在下圖中的線上施加一個約束，使其平行於矩形的左側（該線最初與矩形成一定角度）。 \n \xa0顯示草圖約束 單擊此圖標將以白色顯示與該特定草圖中的實體相關的所有選項。 \n 顯示/刪除約束 該窗口列出了與所選任何實體相關的所有約束和約束類型。您可以刪除任何列出的約束或更改約束的順序。 狀態行中顯示不受約束的自由度數。所有這些都應通過應用約束來遵循嚴格的模型來刪除。 \n \xa03.5範例 \n \n 40723102操作影片 \n \n 3.6練習 \n 3.6.1圓形底座本手冊的幾章中將出於多種目的使用的一種模型是具有十多個組件的簡化的刀桿壓機。我們在本章的示例3.5.1中為這些組件之一建模。另一個組件是圓形底座，用於將工件固定在壓力機下。使用下面給出的尺寸對圓形底座進行建模（尺寸以毫米為單位）。 \n \n 3.6.2固定器的草圖在第4章的練習之一中，將要求您為固定器建模。建模3D支架需要多個2D草圖。作為該練習的起點，對下圖所示的2D草圖進行建模並保存文件（所有尺寸均以英寸為單位）。 \n \n \n \n', 'tags': '', 'url': 'CHAPTER 3 – TWO DIMENSIONAL SKETCHING.html'}, {'title': 'Stress Analysis', 'text': '第八章 有限元素分析 \n 有限元素分析（ FEA ）是有限元素方法（ FEM ）的實際運用，他用於對結構或流體所施加的因素 ( 例如力、壓力、熱量和振動 ) 來做出反應行為。 \n 通常，開始的過程都會先從創建幾何模型開始，之後再將模型細分(網狀化)成許多在特定的節點上連結在一起的簡單幾何形狀的小塊(元素)，而材料的性質和限制條件也會應用在元素上。 \n 在最後，許多軟體像是NX12都能解決有限元素分析（ FEA ）的問題並將結果輸出且可視化。有限元素分析（ FEA ）能夠幫助工程師在製造和測試前，更加了解產品的性能。 \n 有限元素分析（ FEA ）的應用包括結構分析、熱分析、流體力學和電磁兼容性 \n 其中，有限元素分析（ FEA ）最常用於結構和固體力學，並應用於計算機械性能（例如應力和位移）。這些（應力和位移）的計算對機械部件的性能非常重要，甚至能夠預防故障。 \n 本章中，我們將處理實體零件的結構應力和應變分析。 \n https://www.youtube.com/watch?v=fZe79_imPUQ \n \n \n', 'tags': '', 'url': 'Stress Analysis.html'}, {'title': 'NX繪圖認證', 'text': '\n \n --------------------------------------------------------------------------------------- \n \n \n --------------------------------------------------------------------------------------- \n \n \n --------------------------------------------------------------------------------------- \n \n \n --------------------------------------------------------------------------------------- \n \n \n --------------------------------------------------------------------------------------- \n \n \n --------------------------------------------------------------------------------------- \n \n \n --------------------------------------------------------------------------------------- \n \n \n --------------------------------------------------------------------------------------- \n \n \n --------------------------------------------------------------------------------------- \n \n \n', 'tags': '', 'url': 'NX繪圖認證.html'}, {'title': 'Solidworks', 'text': 'solidworks\xa0 brief\xa0 history \n \xa0 \xa0 \xa0 \xa0 Solidworks是由Jon Hirschtick於1993年12月創立的，Jon Hirschtick用100萬美元成立了該公司。 之後Hirschtick招募了一組工程師，他們的目標是創建3D CAD軟件，並且希望這個軟體能夠讓Windows系統的介面成功運作並適合Windows去利用。 \n \xa0 \xa0 \xa0 \xa0 1995年11月，SolidWorks很快發布了。它是Windows的第一個而且也很重要的建模器。事實證明這是CAD後續發展的重要一步，雖然AutoCAD發行得比Solidworks早得多，但SolidWorks為也帶來了新的東西-「3D建模」。因此，3D CAD成為1990年代的焦點。在短短幾個月內，SolidWorks改變了工程師將「創造變為現實」的方式。 \n \xa0 \xa0 \xa0 \xa0 SolidWorks實在令人印象深刻，以至於1997年，它被達索系統公司（DassaultSystèmes）以3.2億美元的驚人股票收購，Jon Hirschtick在接下來的14年留任，在他的領導下，SolidWorks也成功的成長為收入達1億美元的公司。 赫希提克後來離開，創立了另一家我們熟悉的公司Onshape。 \n \xa0 \xa0 \xa0 \xa0\xa0\xa0當SolidWorks於1995年首次發佈時，它確實改變了遊戲規則，有了它，首選平台就從UNIX轉移到了PC， 軟件的成本也從18,000美元變到4,000美元，所需的培訓被大量壓縮為幾天。不用說，SolidWorks徹底改變了每個工程師的桌面。自成立以來，SolidWorks已有了26個版本，每個版本都提供更多功能和增強功能。 \n Solidworks practice \n https://www.youtube.com/watch?v=ZkHTpLE2LiQ \n \n \n', 'tags': '', 'url': 'Solidworks.html'}, {'title': 'SolveSpace', 'text': '', 'tags': '', 'url': 'SolveSpace.html'}, {'title': '繪製自走車', 'text': '繪製及組合自走車練習 \n 輪子:共六顆，每顆尺寸一樣 ，四顆為前輪，兩顆為後輪 \n 連接桿:前輪四顆透過多個連接桿連結至車身，後輪直接連結車身 \n 車身:用四個板子，前後左右各一個，使用板子連接件結合，成為車身 \n ---------------------------------------------------------------------------------- \n 輪子  \n 相同尺寸 共六顆 \n \n ---------------------------------------------------------------------------------- \n 連接桿 系列 \n 連接桿1: 用於連接輪子及其他連接桿 \n \n 連接桿2:與連結桿和連接桿3做結合 \n \n 連接桿3:與和連接桿2做結合，並用90長度桿連結至車身本體 \n \n 連接桿4:後輪連結桿 \n \n ---------------------------------------------------------------------------------- \n 自走車車身 \n 左、右車身板 \n \n 前、後車身板 \n \n 側板連接件:用於連結前後版和左右版 \n \n ---------------------------------------------------------------------------------- \n 組合 \n 將所有繪製的零件組合起來，不太熟悉操作， \n 導致過程中出了很多錯誤，只完成一半的組裝。 \n 第一部分 \n \n 第二部分 \n \n 第三部分 \n \n 第四部分 \n \n 展示 \n \n \n', 'tags': '', 'url': '繪製自走車.html'}, {'title': 'Onshape', 'text': '', 'tags': '', 'url': 'Onshape.html'}, {'title': 'W17協同任務', 'text': '\n', 'tags': '', 'url': 'W17協同任務.html'}, {'title': 'Webots\xa0 W17', 'text': 'https://cyberbotics.com/doc/guide/tutorial-2-modification-of-the-environment \xa0 \n Hands-on #1:  Make sure the my_first_simulation.wbt world file is open, and that the simulation is paused and is at a virtual time of 0. Using the File / Save World As... menu, save the simulation as obstacles.wbt. \n 確保先前儲存的文件已經打開,並將模擬暫停及時間歸零,在另存成obstacles.wbt \n Hands-on #2:   To remove the RectangleArena, select it either in the 3D view or in the scene tree view with a left click and press the Delete key on your keyboard. Alternatively, you can right click on it in the 3D view and select Delete in the context menu (you can also use the context menu directly in the scene tree view). Select the TexturedBackroundLight node and click on the Add button. In the open dialog box, and choose PROTO nodes (Webots Projects) / objects / floors / Floor (Solid). \n 在3D試圖或場景樹中將 RectangleArenag 刪除並點選 TexturedBackroundLight 再點 add 並依路徑選擇 PROTO nodes (Webots Projects) / objects / floors / Floor (Solid) \n Hands-on #3:   In the scene tree view select and expand the Floor. Modify the size field and set it to {1, 1} to resize it to 1mx1m. \n 將 Floor 展開 將 size 字段修改成 1X1 \n The solid node (實體節點) \n A Solid node represents a rigid body,To define a rigid body, you will have to create a Solid node. Inside this node you will set up different sub-nodes corresponding to the characteristics of the rigid body. The following figure depicts a rigid body and its sub-nodes. The graphical representation of the Solid node is defined by the Shape nodes populating its children list. The collision bounds are defined in its boundingObject field. The graphical representation and the collision shape are often but not necessarily identical. Finally, the physics field defines if the object belongs to the dynamical or to the static environment. All these sub-nodes are optional, but the physics field needs the boundingObject to be defined. \n Solid節點代表一個剛體,在節點內可依缸體特性設置子節點,下圖描繪了剛體及子節點 下圖以 Shape 定義 Solid節點中的children。在 boundingObject 字段中定義碰撞範圍。圖形表示與碰撞形狀不一定相同。physics字段是定義屬於動態環境或靜態環境,但需要 boundingObject 定義該字段。 \n \n Create A Ball (創建一個球) \n Hands-on #4:  In the scene tree view, select the last node and press the Add button. In the dialog, open the Bases nodes section and select the Solid node. In the scene tree view, expand the Solid node and select its children field. Add a Shape node to it by using the Add button. Select the appearance field of the Shape node and use the Add button to add a PBRAppearance node. \n 1.Add a Sphere node as the geometry field of the newly created Shape node. 2.Expand the PBRAppearance node and change its metalness field to 0 and its roughness field to 1. 3.Add another Sphere node to the boundingObject field of the Solid. 4.Finally add a Physics node to the physics field of the Solid. 5.By modifying the translation field of the Solid node, place the ball in front of the robot (at {0, 0.2, -0.2} for example). 6.Save the simulation. 7.The result is depicted in this figure. \n \n 步驟#4:在場景視圖中，選擇最後一個節點並且按"ADD"鈕，在對話框裡打開"基礎"節點(Bases nodes)，接著選擇"實體"節點(Solid node)。 \n 在場景視圖中，展開"實體"節點(Solid node)，然後選擇子字段(children field)，按"ADD"新增一個"形狀"節點，選擇形狀節點中的外觀字段， 接著按"ADD" 鈕 新增一個"PBRAppearance"節點。 \n 1.新增一個球體節點(Sphere node)作為新建的形狀節點的幾何字段。 2.展開PBRAppearance節點，並且將金屬字段設定0，接著粗糙度字段設定1。 3.新建另一個球體節點(Sphere node)，並添加到實體的 boundingObject 字段。 4.最後，新增一個Physics節點到實體中的Physical字段。 5.修該時體節點的平移字段，把球放在機器人面前(例如:在座標[0,0.2,-0.2])。 6.儲存模擬。 7.結果如圖所示。 \n \n Geometries (幾何形狀) \n Hands-on #5:  For each Sphere node defining the ball, set its radius field to 0.05 and its subdivision field to 2. Refer to the Reference Manual to understand what the subdivision field stands for. \n 步驟#5:定義每個球體節點，將半徑字段設置為0.05，並且把細分(subdivision)字段設定為2，請查閱《參考手冊》了解細分字段的意義。 \n DEF-USE Mechanism \n 定義使用原理 \n Hands-on #6:   Select the first Sphere node (the child of the Shape) in the scene tree view. The field editor of the scene tree view allows you to enter the DEF string. \n 動手操作6 : 在左邊場景列中選擇第一個Sphere模型(Shape的次級模型)。  點選場景列中的 field editor，這裡可以讓你輸入指令。 \n \n 1.Enter BALL_GEOMETRY in this field. 第一步 : 輸入 BALL_GEOMETRY  2.Select the boundingObject field (containing the second Sphere node), and empty it by right clicking the field in the scene tree and choosing the Delete entry in the context menu that pops up. 第二步 : 選擇boundingObject(包含第二個的Sphere模型)，然後點擊右鍵選擇刪除 3.Then, select the boundingObject field and click on the Add button, and select the USE / BALL_GEOMETRY in the dialog box. 第三步 : 然後選擇 boundingObject ，點選添加後在對話中選擇 USE / BALL_GEOMETRY 4.The result is shown in this figure. \n 結果如圖所示 \n \n \n \n Hands-on #7 :  Create a second ball with the same parameters but using the\xa0 Shape \xa0node (rather than the\xa0 Sphere \xa0node directly) for the DEF-USE mechanism . \n 使用DEF-USE機制的Shape節點（不是直接使用Sphere節點）新建第二個有相同參數的球 \n Add Walls 添置牆壁 \n In order to verify your progression, implement by yourself four walls to surround the environment. 為了確認你的進度，請自己在環境中設置四道牆。 The walls have to be defined statically to the environment. Understand the difference between static and dynamic 必須根據環境的條件去定義牆壁，並區分動態與靜態的區別。 \n Hands-on #8:  Add four walls without physics and using only one definition of the Shape node. 僅使用形狀的定義去添加牆壁 \n \n Solution: World File 解決方案：世界文件 To compare your world with the solution, 為了將您的世界與解決方案進行比較，  go to your files and find the folder named "my_first_simulation" created in Tutorial 1, 轉到文件，找到在教程1中創建的名為“ my_first_simulation”的文件夾  then go to the "worlds" folder and open with a text editor the right world.  然後轉到“世界”文件夾，並使用文本編輯器打開正確的世界。 This solution as the others is located in the solution directory. 與其他解決方案一樣，該解決方案位於解決方案目錄中。 \n \n Efficiency /\xa0 效率 The simulation of rigid bodies is computationally expensive.  剛體的模擬在計算上是昂貴的。 The simulation speed can be increased by minimizing the number of bounding objects,  通過最小化邊界對象的數量可以提高仿真速度， minimizing the constraints between them (more information about the constraints in the next tutorials), 使它們之間的約束最小化（有關下一個約束的更多信息）， and maximizing the WorldInfo.basicTimeStep field.   並最大化WorldInfo.basicTimeStep字段。 On each simulation, 在每次模擬中 a trade-off has to be found between simulation speed and realism. 必須在仿真速度和真實性之間找到一個權衡。 \n Conclusion 結論 At the end of this tutorial, 在本教程的最後， you are able to create simple environments based on rigid bodies.  您能夠基於剛體創建簡單的環境。 You are able to add nodes from the scene tree view and to modify their fields. 您可以從場景樹視圖添加節點並修改其字段。 You have become acquainted with the Solid,Physics, Shape, Sphere and Box nodes. 您已經熟悉了實體，物理，形狀，球體和盒子節點。 You also saw the DEF-USE mechanism that allows to reduce node redundancy of the scene tree. 您還看到了DEF-USE機制，該機制可減少場景樹的節點冗餘。 \n', 'tags': '', 'url': 'Webots\xa0 W17.html'}, {'title': '40723110', 'text': 'DEF-USE Mechanism \n 定義使用原理 \n Hands-on #6: \xa0 Select the first Sphere node (the child of the Shape) in the scene tree view. The field editor of the scene tree view allows you to enter the DEF string. \n 動手操作6 : 在左邊場景列中選擇第一個Sphere模型(Shape的次級模型)。 點選場景列中的 field editor，這裡可以讓你輸入指令。 \n \n 1.Enter BALL_GEOMETRY in this field. 第一步 : 輸入 BALL_GEOMETRY 2.Select the boundingObject field (containing the second Sphere node), and empty it by right clicking the field in the scene tree and choosing the Delete entry in the context menu that pops up. 第二步 : 選擇boundingObject(包含第二個的Sphere模型)，然後點擊右鍵選擇刪除 3.Then, select the boundingObject field and click on the Add button, and select the USE / BALL_GEOMETRY in the dialog box. 第三步 : 然後選擇 boundingObject ，點選添加後在對話中選擇 USE / BALL_GEOMETRY 4.The result is shown in this figure. \n 結果如圖所示 \n \n \n \n Hands-on #7 : \xa0 Create a second ball with the same parameters but using the\xa0 Shape \xa0node (rather than the\xa0 Sphere \xa0node directly) for the DEF-USE mechanism . \n 使用DEF-USE機制的Shape節點（不是直接使用Sphere節點）新建第二個有相同參數的球 \n Add Walls 添置牆壁 \n In order to verify your progression, implement by yourself four walls to surround the environment. 為了確認你的進度，請自己在環境中設置四道牆。 The walls have to be defined statically to the environment. Understand the difference between static and dynamic 必須根據環境的條件去定義牆壁，並區分動態與靜態的區別。 \n Hands-on #8: \xa0 Add four walls without physics and using only one definition of the Shape node. 僅使用形狀的定義去添加牆壁 \n', 'tags': '', 'url': '40723110.html'}, {'title': '40723112', 'text': 'Create A Ball (創建一個球) \n Hands-on #4: \xa0 In the scene tree view, select the last node and press the Add button. In the dialog, open the Bases nodes section and select the Solid node. In the scene tree view, expand the Solid node and select its children field. Add a Shape node to it by using the Add button. Select the appearance field of the Shape node and use the Add button to add a PBRAppearance node. \n 1.Add a Sphere node as the geometry field of the newly created Shape node. 2.Expand the PBRAppearance node and change its metalness field to 0 and its roughness field to 1. 3.Add another Sphere node to the boundingObject field of the Solid. 4.Finally add a Physics node to the physics field of the Solid. 5.By modifying the translation field of the Solid node, place the ball in front of the robot (at {0, 0.2, -0.2} for example). 6.Save the simulation. 7.The result is depicted in this figure. \n \n 步驟#4:在場景視圖中，選擇最後一個節點並且按"ADD"鈕，在對話框裡打開"基礎"節點(Bases nodes)，接著選擇"實體"節點(Solid node)。 \n 在場景視圖中，展開"實體"節點(Solid node)，然後選擇子字段(children field)，按"ADD"新增一個"形狀"節點，選擇形狀節點中的外觀字段， 接著按"ADD" 鈕 新增一個"PBRAppearance"節點。 \n 1.新增一個球體節點(Sphere node)作為新建的形狀節點的幾何字段。 2.展開PBRAppearance節點，並且將金屬字段設定0，接著粗糙度字段設定1。 3.新建另一個球體節點(Sphere node)，並添加到實體的 boundingObject 字段。 4.最後，新增一個Physics節點到實體中的Physical字段。 5.修該時體節點的平移字段，把球放在機器人面前(例如:在座標[0,0.2,-0.2])。 6.儲存模擬。 7.結果如圖所示。 \n \n Geometries (幾何形狀) \n Hands-on #5: \xa0 For each Sphere node defining the ball, set its radius field to 0.05 and its subdivision field to 2. Refer to the Reference Manual to understand what the subdivision field stands for. \n 步驟#5:定義每個球體節點，將半徑字段設置為0.05，並且把細分(subdivision)字段設定為2，請查閱《參考手冊》了解細分字段的意義。 \n', 'tags': '', 'url': '40723112.html'}, {'title': '40723136', 'text': 'Solution: World File 解決方案：世界文件 To compare your world with the solution, 為了將您的世界與解決方案進行比較， go to your files and find the folder named "my_first_simulation" created in Tutorial 1, 轉到文件，找到在教程1中創建的名為“ my_first_simulation”的文件夾 then go to the "worlds" folder and open with a text editor the right world. 然後轉到“世界”文件夾，並使用文本編輯器打開正確的世界。 This solution as the others is located in the solution directory. 與其他解決方案一樣，該解決方案位於解決方案目錄中。 \n \n Efficiency /\xa0 效率 The simulation of rigid bodies is computationally expensive. 剛體的模擬在計算上是昂貴的。 The simulation speed can be increased by minimizing the number of bounding objects, 通過最小化邊界對象的數量可以提高仿真速度， minimizing the constraints between them (more information about the constraints in the next tutorials), 使它們之間的約束最小化（有關下一個約束的更多信息）， and maximizing the WorldInfo.basicTimeStep field. 並最大化WorldInfo.basicTimeStep字段。 On each simulation, 在每次模擬中 a trade-off has to be found between simulation speed and realism. 必須在仿真速度和真實性之間找到一個權衡。 \n Conclusion 結論 At the end of this tutorial, 在本教程的最後， you are able to create simple environments based on rigid bodies. 您能夠基於剛體創建簡單的環境。 You are able to add nodes from the scene tree view and to modify their fields. 您可以從場景樹視圖添加節點並修改其字段。 You have become acquainted with the Solid,Physics, Shape, Sphere and Box nodes. 您已經熟悉了實體，物理，形狀，球體和盒子節點。 You also saw the DEF-USE mechanism that allows to reduce node redundancy of the scene tree. 您還看到了DEF-USE機制，該機制可減少場景樹的節點冗餘。 \n', 'tags': '', 'url': '40723136.html'}, {'title': '40723148', 'text': 'https://cyberbotics.com/doc/guide/tutorial-2-modification-of-the-environment \xa0 \n Hands-on #1: \xa0 Make sure the my_first_simulation.wbt world file is open, and that the simulation is paused and is at a virtual time of 0. Using the File / Save World As... menu, save the simulation as obstacles.wbt. \n 確保先前儲存的文件已經打開,並將模擬暫停及時間歸零,在另存成obstacles.wbt \n Hands-on #2: \xa0 To remove the RectangleArena, select it either in the 3D view or in the scene tree view with a left click and press the Delete key on your keyboard. Alternatively, you can right click on it in the 3D view and select Delete in the context menu (you can also use the context menu directly in the scene tree view). Select the TexturedBackroundLight node and click on the Add button. In the open dialog box, and choose PROTO nodes (Webots Projects) / objects / floors / Floor (Solid). \n 在3D試圖或場景樹中將 RectangleArenag 刪除並點選 TexturedBackroundLight 再點 add 並依路徑選擇 PROTO nodes (Webots Projects) / objects / floors / Floor (Solid) \n Hands-on #3: \xa0 In the scene tree view select and expand the Floor. Modify the size field and set it to {1, 1} to resize it to 1mx1m. \n 將 Floor 展開 將 size 字段修改成 1X1 \n The solid node (實體節點) \n A Solid node represents a rigid body,To define a rigid body, you will have to create a Solid node. Inside this node you will set up different sub-nodes corresponding to the characteristics of the rigid body. The following figure depicts a rigid body and its sub-nodes. The graphical representation of the Solid node is defined by the Shape nodes populating its children list. The collision bounds are defined in its boundingObject field. The graphical representation and the collision shape are often but not necessarily identical. Finally, the physics field defines if the object belongs to the dynamical or to the static environment. All these sub-nodes are optional, but the physics field needs the boundingObject to be defined. \n Solid節點代表一個剛體,在節點內可依缸體特性設置子節點,下圖描繪了剛體及子節點 下圖以 Shape 定義 Solid節點中的children。在 boundingObject 字段中定義碰撞範圍。圖形表示與碰撞形狀不一定相同。physics字段是定義屬於動態環境或靜態環境,但需要 boundingObject 定義該字段。 \n \n', 'tags': '', 'url': '40723148.html'}, {'title': 'CoppeliaSimPro', 'text': "Building a clean model tutorial \n 建立一個簡潔的模型教學 \n This tutorial will guide you step-by-step into building a clean simulation model, of a robot, or any other item. This is a very important topic, maybe the most important aspect, in order to have a nice looking, fast displaying, fast simulating and stable simulation model. \n 這個教學會一步一步的引導你去建造出一個簡潔可模擬模型、機器人，或任何其他項目。這是一個非常重要的主題，或許是最重要的方面‧為了有良好的外觀、迅速的展示、模擬，然後穩定的模擬模型。 \n To illustrate the model building process, we will be building following manipulator: \n 為了說明建造模型的過程，我們會建立一個機械手臂 : \n \n Building the visible shapes \n 建立可見的形狀 \n When building a new model, first, we handle only the visual aspect of it: the dynamic aspect (its undelying even more simplified/optimized model), joints, sensors, etc. will be handled at a later stage. \n 當建立新的模型時，首先，我們先處理模組大小規格 : 動態方面 ( 讓模型簡化 / 優化 ) ，支點，感應器 ….. 等等，之後會將處理。 \n We could now directly create primitive shapes in CoppeliaSim with [Menu bar --> Add --> Primitive shape --> ...]. When doing this, we have the option to create\xa0 pure shapes, or regular shapes . Pure shape will be optimized for dynamic interaction, and also directly be dynamically enabled (i.e. fall, collide, but this can be disabled at a later stage). Primitive shapes will be simple meshes, which might not contain enough details or geometric accuracy for our application. Our other option in that case would be to import a mesh from an external application. \n 我們可以直接在 CoppeliaSim 建立原始形狀 [Menu bar --> Add --> Primitive shape --> ...] 當這樣做時，我們可以選擇創建純粹的形狀或是有規格的形狀，純粹的形狀將會對動態的互動進行優化，爾且可以直接啟用動態 ( 例如 : 跌落、破狀，這些也可以在之後關掉 ) ，基本的形狀就是簡單得網格，對於我們的運用可能沒有足夠的細節或是幾何精度。在這種情況下，我們的可以選擇從外部應用程式導入網格。 \n When importing CAD data from an external application, the most important is to make sure that the CAD model is not too heavy, i.e. doesn't contain too many triangles. This requirement is important since a heavy model will be slow in display, and also slow down various calculation modules that might be used at a later stage (e.g. \xa0 minimum distance calculation , or \xa0 dynamics ). Following example is typically a no-go (even if, as we will see later, there are means to simplify the data within CoppeliaSim): \n \xa0 \n 從外部應用程式匯入 CAD 資料時，最重要的是要確保 CAD 的模型不會有太多複雜的面，例如 : 不要包含太多的三角形。此要求很重要，因為有太多複雜面的模型在顯示時會非常緩慢，還會減慢了之後可能使用的各種計算模塊 ( 例如 : 最小距離計算或是動態計算 ) ， 以下示例通常是不行的 ( 即使是下方的例子也有方法可以簡化 CoppeliaSim 中的數據 ) \n \n Above CAD data is very heavy: it contains many triangles (more than 47'000), which would be ok if we would just use a single instance of it in an empty scene. But most of the time you will want to simulate several instances of a same robot, attach various types of grippers, and maybe have those robots interact with other robots, devices, or the environment. In that case, a simulation scene can quickly become too slow. Generally, we recommend to model a robot with no more than a total of 20'000 triangles, but most of the time 5'000-10'000 triangles would just do fine as well. Remember: less is better, in almost every aspect. \n 關於 CAD 資料太大 : 這包含太多三角形 ( 超過 47000 個 ) ， 如果我們只在空場景中使用一個實例，那沒關係，但是大多數時候，你會想要模擬同一個機器人的多個實例、附加各種類型的爪子、或許也會讓那些機器人與其他機器人互動、還有其他設備或環境。在下面的例子，模擬場景可能快速變得緩慢，通常，我們建議對不超過 2 萬個三角形的機器人進行建模。大多數時用 5000~10000 個三角形比較好，記住 : 幾乎所有方面都是越少越好。 \n What makes above model so heavy? First, models that contain holes and small details will require much more triangular faces for a correct representation. So, if possible, try to remove all the holes, screws, the inside of objects, etc. from your original model data. If you have the original model data represented as parametric surfaces/objects, then it is most of the time a simple matter of selecting the items and deleting them (e.g. in Solidworks). The second important step is to export the original data with a limited precision: most CAD applications let you specify the level of details of exported meshes. It might also be important to export the objects in several steps, when the drawing consists of large and small objects; this is to avoid having large objects too precisely defined (too many triangles) and small objects too roughly defined (too few triangles): simply export large objects first (by adjusting the desired precision settings), then small objects (by adjusting up precision settings). \n 是什麼讓上述模型太大 ? 首先，有包含孔和小細節的模型將需要更多的三角形面才能正確顯示 ，所以可能的話，嘗試從原始模型中刪除所有孔，螺釘，物體內部物件等。如果原始模型顯示有參數化的曲面 / 物件，那麼在大多數情況下，選擇項目並刪除它們就很簡單了 ( 例如 : 在 Solidworks 中 ) 。第二個重要步驟是在有限的精度中導出原始資料 : 大多數 CAD 應用程序可讓您指定導出網格的詳細程度，當圖形包含大小物件時，分步導出物件也是很重要的 ; 這是為了避免大物件定義太精確 ( 太多三角形 ) 而小物件定義太粗糙 ( 太少三角形 ) ，先導出大型的物件 ( 通過所需的調整精度設置 ) 然後是小物件 ( 在調整精度設置 ) 。 \n \xa0CoppeliaSim supports currently following CAD data formats:\xa0 OBJ , \xa0 STL , \xa0 DXF , \xa0 3DS \xa0 (Windows only), and \xa0 Collada . \xa0 URDF \xa0 is also supported, but not mentionned here since it is not a pure mesh-based file format. \n CoppeliaSim 支援當前以下 CAD 數據格式 :OBJ 、 STL 、 DXF 、 3DS( 限定 Windows) 、 Collada 。還有 URDF 也是支援的，但是這裡沒有提到，因為它不是基於網格的純文件格式。 \n Now suppose that we have applied all possible simplifications as described in previous section. We might still end-up with a too heavy mesh after import: \n 現在假設我們已經按照上一節中的描述使用了所有可能的簡化，我們可能最終在導入後仍然會留下太多的網格 : \n \n You can notice that the whole robot was imported as a single mesh. We will see later how to divide it appropriately. Notice also the wrong orientation of the imported mesh: best is to keep the orientation as it is, until the whole model was built, since, if at a later stage we want to import other items that are related to that same robot, they will automatically have the correct position/orientation relative to the original mesh. \n 你可能注意到整個機器人是作為單個網格導入的，之後我們將看到如何對它進行適當分開，還要注意導入的網格是否方向錯 : 建立完整模型之前，最好是保持原樣，因為，如果以後要導入與同一機器人相關的其他項目，它們將自動保有相對於原始網格的正確位置 / 方向。 \n At this stage, we have several functions at our disposal, to simplify the mesh: \n 在此階段，我們可以使用多種功能來簡化網格： \n \n \n Automatic mesh division: \xa0 allows to generate a new shape for all elements that are not linked together via a common edge. This does not always work for the selected mesh, but is always worth a try, since working on mesh elements gives us more control than if we had to work on all elements at the same time. The function can be accessed with [Menu bar --> Edit --> Grouping/Merging --> Divide selected shapes]. Sometimes, a mesh will be divided more than expected. In that case, simply merge elements that logically belong together (i.e. that will have the same visual attributes and that are part of the same link) back into one single shape ([Menu bar --> Edit -> Grouping/Merging --> Merge selected shapes]). \n Extract the convex hull: \xa0 allows to simplify the mesh by transforming it into a convex hull. The function can be accessed with [Menu bar --> Edit --> Morph selection into convex shapes]. \n Decimate the mesh: \xa0 allows to reduce the number of triangles contained in the mesh. The function can be accessed with [Menu bar --> Edit --> Decimate selected shape...]. \n Remove the inside of the mesh: \xa0 allows to simplify the mesh by removing its inside. This function is based on \xa0 vision sensors \xa0 and might give more or less satisfying results depending on the selected settings. The function can be accessed with [Menu bar --> Edit --> Extract inside of selected shape]. \n ‧ Automatic mesh division : 允許為所有元素生成新形狀，當他們沒有通過共同的邊緣鏈接在一起時，這個不是一直有用於選定的網格，但是值得一試，因為與必須同時處理所有元素相比，處理網格元素可以為我們提供更多的控制權。該功能可以通過 [Menu bar --> Edit --> Grouping/Merging --> Divide selected shapes] 。有時候，網格的劃分將超出預期。在這種情況下，只需合併邏輯上屬於一起的元素 ( 例如 : 具有相同的視覺屬性，並且是同一鏈接的一部分 ) 回到一個單一的形狀 ([Menu bar --> Edit -> Grouping/Merging --> Merge selected shapes]) \n ‧ Extract the convex hull: 通過將其轉換為凸包來簡化網格，該功能可以通過 [Menu bar --> Edit --> Morph selection into convex shapes]. \n ‧ Decimate the mesh: 允許減少網格中包含的三角形數量，該功能可以通過 [Menu bar --> Edit --> Decimate selected shape...] \n ‧ Remove the inside of the mesh: 允許通過刪除其內部來簡化網格。此功能基於視覺傳感器，並且可能會根據所選設置提供或多或少令人滿意的結果，該功能可以通過 [Menu bar --> Edit --> Extract inside of selected shape] \n There is no predefined order in which above functions can/should be applied (except for the first item in the list, which should always be tried first), it heavily depends on the geometry of the mesh we are trying to simplify. Following image illustrates above functions applied to the imported mesh (let's suppose the first item in the list didn't work for us): \n \n 上述的功能沒有定義應該使用的順序 ( 除列表中的第一項外，應始終先嘗試 ) ，在很大程度上取決於我們要簡化網格的幾何形狀，下圖說明了上述功能導入網格的應用 ( 假設列表中的第一項對我們不起作用 ): \n \n Notice how the convex hull doesn't help us at this stage. We decide to use the mesh decimation function first, and run the function twice in order to divide the number of triangles by a total of 50. Once that is done, we extract the inside of the simplified shape and discard it. We end-up with a mesh containing a total of 2'660 triangles (the original imported mesh contained more than 136'000 triangles!). The number of triangles/vertices a shape contains can be seen in the\xa0 shape geometry dialog . 2'660 triangles are extremely few triangles for a whole robot model, and the visual appearance might suffer a little bit from it. \n 請注意，凸包在現階段如何對我們沒有幫助。我們先決定使用網格的抽取功能，並將此功能運行兩次以至三角形的總數到 50 ，一旦完成，我們提取簡化形狀的內部並將其丟棄，我們最終得到一個總共 2'660 個三角形的網格 ( 原始導入的網格超過 136'000 個三角形 ) 。 整個模型包含的三角形 / 頂點的數量可以在形狀幾何對話框中看到， 2'660 個三角形對於整個機器人模型來說是很少的三角形，但是視覺外觀可能會因此受到一點影響。 \n At this stage we can start to divide the robot into separate links (remember, we currently have only a single shape for the whole robot). You can do this in two different ways: \n 在這一階段，我們可以開始將機器人劃分為單獨的鏈接 ( 請記住，我們目前整個機器人只有一個形狀 ) ，你可以通過兩種不同的方式執行此操作： \n \n \n Automatic mesh division: \xa0 this function, which was already described in previous section, will inspect the shape and generate a new shape for all elements that are not linked together via a common edge. This does not always work, but is always worth a try. The function can be accessed with [Menu bar --> Edit --> Grouping/merging --> Divide selected shapes]. \n Manual mesh division: \xa0 via the the \xa0 triangle edit mode , you can manually select the triangles than logically belong together, then click \xa0 Extract shape . This will generate a new shape in the scene. Delete the selected triangles after that operation. \n \n ‧ Automatic mesh division: 這個功能，上一節已經描述過了，將檢查形狀並為未通過公共邊鏈接在一起的所有元素生成新形狀，這並不總是有效， 但是值得一試，該功能可以通過 [Menu bar --> Edit --> Grouping/Merging --> Divide selected shapes] 。 \n ‧ Manual mesh division: 通過三角形編輯模式，您可以手動選擇邏輯上屬於三角形的三角形，點擊 Extract shape 。這將在場景中產生新的形狀，完成該操作後，刪除選定的三角形。 \n In the case of our mesh, method 1 worked fine: \n 在這個例子中我們的網格，方法 1 效果很好 : \n \n Now, we could further refine/simplify individual shapes. Sometimes also, a shape might look better if its convex hull is used instead. Othertimes, you will have to use several of above's described techniques iteratively, in order to obtain the desired result. Take for instance following mesh: \n \n \n 現在，我們可以進一步細化 / 簡化單個形狀，有時也可以使用凸包代替形狀，有時，您將不得不反複使用上述幾種技術，以獲得所需的結果。 以以下網格為例： \n \n The problem with above's shape is that we cannot simplify it nicely, because of the holes it contains. So we have to go the more complicated way via the\xa0 shape edit mode , where we can extract individual elements that logically belong to the same convex sub-entity. This process can take several iterations: we first extract 3 approximate convex elements. For now, we ignore the triangles that are part of the two holes. While editing a shape in the shape edit mode, it can be convenient to switch the \xa0 visibility layers , in order to see what is covered by other scene items. \n 上面形狀的問題是我們不能很好地簡化它，因為它包含孔。因此，我們必須通過形狀編輯模式採用更複雜的方法，在這裡我們可以提取在邏輯上屬於同一個凸子實體的單個元素。此過程可能需要多次重覆：首先我們提取 3 個近似凸元素。現在，我們忽略為兩個孔的一部分的三角形。在形狀編輯模式下編輯形狀時，切換可見性層會很方便，還有方便查看其他場景項目所涵蓋的內容。 \n \n We end up with a toal of three shapes, but two of them will need further improvement. Now we can erase the triangles that are part of the holes. Finally, we extract the convex hull individually for the 3 shapes, then merge them back together with [Menu bar --> Edit --> Grouping/Merging --> merge selected shapes]: \n 我們最終得到三種形狀，但是其中兩個將需要進一步改進。現在我們可以刪除作為孔的一部分的三角形。最後，我們分別提取 3 種形狀的凸包，然後將它們合併在一起 [Menu bar --> Edit --> Grouping/Merging --> merge selected shapes]: \n \n In CoppeliaSim, we can enable/disable edge display for each shape. We can also specify an angle that will be taken into account for the edge display. A similar parameter is the\xa0 shading angle , that dictates how facetted the shape will display. Those parameters, and a few others such as the shape \xa0 color , can be adjusted in the \xa0 shape properties . Remember that \xa0 shapes come in various flavours . In this tutorial we have only dealt with simple shapes up to now: a simple shape has a single set of visual attributes (i.e. one color, one shading angle, etc.). If you merge two shapes, then the result will be a simple shape. You can also group shapes, in which case, each shape will retain its visual attributes. \n 在 CoppeliaSim 中，我們可以啟用 / 禁用每種形狀的邊緣顯示。我們還可以指定邊緣顯示時要考慮的角度。相似的參數是陰影角，決定形狀如何顯示。那些參數，還有其他一些，例如形狀顏色 ，可以調整形狀屬性。請記住形狀各異。在本教程中，到目前為止，我們僅處理了簡單的形狀 : 一個簡單的形狀具有一組視覺屬性 ( 例如一種顏色，一種陰影角度等 ) 。如果合併兩個形狀，那麼結果將是一個簡單的形狀。您還可以對形狀進行分組，在這種情況下，每個形狀將保留其視覺屬性。 \n In next step, we can merge elements that logically belong together (if they are part of the same rigid element, and if they have the same visual attributes). Then we change the visual attributes of the various elements. The easiest ist to adjust a few shapes that have different colors and visual attributes, and if we name the color with a specific string, we can later easily programmatically change that color, also if the shape is part of a compound shape. Then, we select all the shapes that have the same visual attributes, then control-select the shape that was already adjusted, then click \xa0 Apply to selection , once for the \xa0 Colors , once for the \xa0 other properties , in the \xa0 shape properties : this transfers all visual attributes to the selected shapes (including the color name if you provided one). We end up with 17 individual shapes: \n 在下一步中，我們可以合併在邏輯上屬於一樣的元素 ( 如果它們是同一剛性元素的一部分，並且它們具有相同的視覺屬性 ) 。然後我們更改各種元素的視覺屬性。最簡單的方法是調整一些具有不同顏色和視覺屬性的形狀，如果我們用特定的字符串命名顏色，我們以後可以輕鬆地以編程方式更改該顏色，如果形狀是複合形狀的一部分，也是如此。然後，我們選擇具有相同視覺屬性的所有形狀，然後控制選擇已調整的形狀，然後單擊 Apply to selection ，一次用於顏色，一次用於其他屬性，在形狀屬性中：這會將所有視覺屬性轉移到所選形狀 ( 包括顏色名稱，如果提供的話 ) 。 我們最終得到 17 個單獨的形狀： \n \n Now we can group the shapes that are part of the same link with [Menu bar --> Edit --> Grouping/merging -> Group selected shapes]. We end up with 7 shapes: the base of the robot (or base of the robot's hierarchy tree), and 6 mobile links. It is also important to correctly name your objects: you we do this with a double-click on the object name in the\xa0 scene hierarchy . The base should always be the robot or model name, and the other objects should always contain the base object name, like: \xa0 robot \xa0 (base), \xa0 robot_link1 , \xa0 robot_proximitySensor , etc. By defaut, shapes will be assigned to visibility layer 1, but can be changed in the \xa0 object common properties . By default, only \xa0 visibility layers 1-8 are activated for the scene . We now have following (the model \xa0 ResizableFloor_5_25 \xa0 was temporarily made invisible in the \xa0 model properties dialog ): \n 現在我們可以將屬於同一鏈接的形狀分組 [Menu bar --> Edit --> Grouping/merging -> Group selected shapes] \xa0 我們最終得到 7 種形狀機器人的基底 ( 或機器人層次結構樹的基礎 ) ，和 6 個移動鏈接。正確命名物件也很重要 : 您可以通過雙擊場景層次中的對象名稱來執行此操作。基礎應該始終是機器人或型號名稱，其他對象應始終包含基礎對象名稱，例如： robot(base) ， robot_link1 ， robot_proximitySensor 等。默認情況下，形狀將分配給可見性圖層 1 ，但是可以更改對象的通用屬性。默認情況下，僅激活場景的可見性層 1-8 。我們現在有以下 ( 模型 ResizableFloor_5_25 在模型屬性對話框中暫時不可見 ): \n \n \n When a shape is created or modified, CoppeliaSim will automatically set its reference frame position and orientation. A shape's reference frame will always be positioned at the shape's geometric center. The frame orientation will be selected so that the shape's bounding box remains as small as possible. This does not always look nice, but we can always reorient a shape's reference frame at any time. We now reorient the reference frames of all our created shapes with [Menu bar --> Edit --> Reorient bounding box --> with reference frame of world]. You have more options to reorient a reference frame in the\xa0 shape geometry dialog . \n 創建或修改形狀時， CoppeliaSim 將自動設置其參考框架的位置和方向，形狀的參考框架將始終位於形狀的幾何中心。將選擇框架方向，以便形狀的邊界框保持盡可能小。這並不是一直看起來不錯，但是我們總是可以隨時調整形狀的參考框架的方向。現在，我們使用以下命令重新調整所有已創建形狀的參考框架的方向： [Menu bar --> Edit --> Reorient bounding box --> with reference frame of world] 。您有更多選項可以在形狀幾何對話框中重新定向參考框架。 \n", 'tags': '', 'url': 'CoppeliaSimPro.html'}, {'title': '40723102', 'text': "http://www.coppeliarobotics.com/helpFiles/en/buildingAModelTutorial.htm \n 第四段型號定義 Model definition \n 現在我們準備定義模型了。我們首先構建模型層次結構：我們附加了最後一個動態機器人鏈接\xa0( robot_link_dyn6 ) ，到其對應的關節( robot_joint6 )\xa0，選擇 \xa0( robot_link_dyn6 ) 然後控制選擇 ( robot_joint6 )\xa0, 之後然後點擊 [ 菜單欄 -> 編輯 -> 將最後選擇的對象設為主對象 ] 。我們也可以藉由簡單地將對象 robot_link_dyn6 拖動到場景層次中的 robot_link6 上完成此步驟。 \n Now we are ready to define our model. We start by building the model herarchy: we attach the last dynamic robot link ( robot_link_dyn6 ) to its corresponding joint ( robot_joint6 ) by selecting \xa0 robot_link_dyn6 , then control-selecting \xa0 robot_joint6 , then [Menu bar --> Edit --> Make last selected object parent]. We could also have done this step by simply dragging object \xa0 robot_link_dyn6 \xa0 onto \xa0 robot_link6 \xa0 in the \xa0 scene hierarchy \n 現在，我們將 robot_joint6 附加到 robot_link_dyn5 上，依此類推，直到到達機器人的底部。 \n \xa0We go on by now attaching\xa0 robot_joint6 \xa0 to \xa0 robot_link_dyn5 , and so on, until arrived at the base of the robot. \xa0 \n 現在，我們具有以下場景層次結構： \n We now have following scene hierarchy \n \xa0 \n 為模型起一個簡單的名字是很好而且更合乎邏輯的，因為模型庫也將代表模型本身。所以我們命名這個機械手臂為 robot_visibleBase , \xa0 robot_dyn 。 \n It is nice and more logical to have a simple name for the model base, since the model base will also represent the model itself. So we rename \xa0 robot \xa0 to \xa0 robot_visibleBase , and \xa0 robot_dyn \xa0 to \xa0 robot . \n 現在我們選擇層次樹的基礎(i.e. object\xa0 robot )，在對象的公共屬性中，我們啟用物體是模型 \n Now we select the base of the hierarchy tree (i.e. object \xa0 robot ) and in the \xa0 object common properties \xa0 we enable \xa0 Object is model base . \xa0 \n 我們還使物體 / 模型可以轉移或接受 DNA 。 \n \xa0We also enable \xa0 Object/model can transfer or accept DNA .\xa0 \n 不顯示為內部模型 \n 模型邊界框可以包含整個機器人。但是如果邊界框太大，邊界框還包含不可見的項目 ( 例如 : 節點 ) \xa0 。這時候可以對所有節點啟用“不顯示為內部模型” \xa0 Don't show as inside model selection 選擇項，將節點從模型邊界框中排除。我們可以對模型中的所有不可見項執行上述的步驟。這也是一個有用的選項，可以將大型傳感器或其他項目也排除在模型邊界框之外。 \n A model bounding box appeared, encompassing the whole robot. The bounding box however appears to be too large: this is because the bounding box also encompasses the invisible items, such as the joints. We now exclude the joints from the model bounding box by enabling the \xa0 Don't show as inside model selection \xa0 item for all joints. We could do the same procedure for all invisible items in our model. This is also a useful option in order to also exclude large sensors or other items from the model bounding box.\xa0 \n \xa0 \n 避免模型遭意外修改 \n 保護我們的模型遭意外修改，選擇機器人中所有可見的對象，然後啟用 “\xa0 選擇模型的基礎 ” \xa0 Select base of model instead ：如果現在點擊場景中的可見鏈接，則會改為選擇機器人的基座。這時候我們可以像對待單個物體一樣操作模型。我們仍然可以通過按住 Shift 鍵並單擊場景來選擇機器人中的可見物件，或在場景層次結構中選擇物件。 \n We now protect our model from accidental modification. We select all visible objects in the robot, then enable\xa0 Select base of model instead : if we now click a visible link in the scene, the base of the robot will be selected instead. This allows us to manipulate the model as if it was a single object. We can still select visible objects in the robot via control-shift-clicking in the scene, or by selecting the object in the scene hierarchy. \xa0 \n 我們將機器人置於正確的默認位置 / 方向。首先，我們將當前場景儲存做為參考（例如，需要在當前機器人上導入具有相同方向的 CAD 數據）。 \n We now put the robot into a correct default position/orientation. First, we save current scene as a reference (e.g. if at a later stage we need to import CAD data that have the same orientation at the curent robot).\xa0 \n 然後我們選擇模型並適當修改其位置 / 方向 \n Then we select the model and\xa0 modify its position/orientation \xa0 appropriately. \n 養成習慣將模型（即其基礎對象）放置在 X = 0 和 Y = 0 處。 \n It is considered good practice to position the model (i.e. its base object) at X=0 and Y=0. \n \n \n 模擬 \n 現在我們進行模擬，由於默認情況下節點不受控制，因此機器人將崩壞。 \n We now run the simulation: the robot will collapse, since the joints are not controlled by default. \xa0 \n 在第三段添加節點時，我們以力 / 扭矩模式創建了節點，但其馬達或控制器已禁用情況下（默認情況下）。可以根據需要調整關節，在我們的案例中，我們希望為每個控制器都提供一個簡單的 PID 控制器。在關節動態屬性中，單擊“啟用電機”並調整最大扭矩。然後，單擊啟用控制環\xa0 Control loop enabled \xa0，然後選擇位置控制（ PID ） Position control (PID) 。 When we added the joints in the previous stage , we created joints in force/torque mode, but their motor or controller was disabled (by default). We can now adjust our joints to our requirements. In our case, we want a simple PID controller for each one of them. In the joint dynamic properties, we click \xa0 Motor enabled \xa0 and adjust the \xa0 maximum torque . We then click \xa0 Control loop enabled \xa0 and select \xa0 Position control (PID) .\xa0 \n 我們再次模擬，則機器人應保持其位置 \n We now run the simulation again: the robot should hold its position. \n 嘗試切換當前的物理引擎，以查看行為在所有受支持的物理引擎之間是否一致。您可以通過相應的工具欄按鈕\xa0toolbar button,或在常規動力學屬性中\xa0general dynamics properties執行此操作。在模擬過程我們通過“\xa0Dynamic content visualization、 verification toolbar button. ”工具欄按鈕來驗證場景動態內容。現在，將僅顯示物理引擎考慮的項目，並且該使用顏色區分。 \xa0 \n Try to switch the current physics engine to see if the behaviour is consistent across all supported physics engines. You can do this via the appropriate\xa0 toolbar button , or in the \xa0 general dynamics properties .During simulation, we now verify the scene dynamic content via the\xa0 Dynamic content visualization & verification toolbar button . Now, only items that are taken into account by the physics engine will be display, and the display is \xa0 color-coded . \n 此操作非常重要，尤其是在動態模型無法按預期運行時，為了快速調整模型。同樣，在模擬過程中請始終注意場景層次：動態啟用的對象應在其名稱的右側顯示一個球形圖示。 \xa0It is \xa0 very important \xa0 to always do this, and specially when your dynamic model doesn't behave as expected, in order to quickly debug the model. Similarly, always look at the scene hierarchy during simulation: dynamically enabled objects should display a ball-bounding icon on the right-hand side of their name. \n \n 最後，我們需要準備機器人，以便我們可以輕鬆地將抓取器連接到它，或輕鬆地將機器人連接到移動平台。可以透過以下兩種不同的方式 \n Finally, we need to prepare the robot so that we can easily attach a gripper to it, or easily attach the robot to a mobile platform (for instance). Two dynamically enabled shapes can be rigidly attached to each other in two different ways: \n 1. by grouping them 將它們分組；選擇形狀 然後 \n [Menu bar 菜單欄 \xa0 --> Edit 編輯 - \xa0 --> Grouping/Merging 分組 / 合併 \xa0 --> Group selected shapes 對選定形狀進行分組 ]. \n by grouping them : select the shapes, then [Menu bar --> Edit --> Grouping/Merging --> Group selected shapes]. \n 2.by attaching them via a force/torque sensor( 通過力 / 扭矩傳感器連接它們 ) : 力扭矩傳感器還可以兩個單獨的動態啟用形狀之間的剛性鏈接。 \n by attaching them via a force/torque sensor : a \xa0 force torque sensor \xa0 can also act as a rigid link between two separate dynamically enabled shapes. \n 只有選項 2 是有意義的。我們建一個力 / 扭矩傳感器\xa0[Menu bar菜單欄 --> Add 添加 - --> Force sensor力傳感器]，然後將其移動到機器人的尖端，然後將其附加到對象 robot_link_dyn6 。我們會適當地更改其尺寸和外觀（紅色力 / 扭矩傳感器通常被視為可選的連接點，請檢查可用的各種機器人型號）。我們將其名稱更改為 robot_attachment ： \n \n In our case, only option 2 is of interest. We create a force/torque sensor with [Menu bar --> Add --> Force sensor], then move it to the tip of the robot, then attach it to object \xa0 robot_link_dyn6 . We change its size and visual appearance appropriately (a red force/torque sensor is often perceived as an optional attachment point, check the various robot models available). We also change its name to \xa0 robot_attachment : \n \n 現在，我們將手臂夾持器模型拖拉到場景中，使其保持選中狀態，然後按住 Control 鍵並點擊附著力傳感器，然後點擊“\xa0Assembling裝配/disassembling拆卸 ”工具欄按鈕。 \n Now we drag a gripper model into the scene, keep it selected, then control-click the attachment force sensor, then click the\xa0 Assembling/disassembling toolbar button . \n 夾持器到位： The gripper goes into place \n \n 夾持器會自己連結，因為它在模型定義期間進行了適當的配置。 \n The gripper knew how to attach itself because it was appropriately configured during its model definition. \n 現在，我們還需要正確配置機器人模型，以便它將知道如何將自己加到移動基座上。我們選擇機器人模型，然後在對象公共屬性中(\xa0object common properties)點擊“組裝”。為“Parent主項”配置一個空字串，然後點擊設置模型，這將記住當前基礎對象的局部轉換模型，並使用它相對於移動機器人的附著點定位/定向。 \n We now also need to properly configure the robot model, so that it will know how to attach itself to a mobile base for instance. We select the robot model, then click\xa0Assembling\xa0in the\xa0 object common properties . Set an empty string for\xa0'Parent' match values, then click\xa0Set matrix. This will memorize the current base object's local transformation matrix, and use it to position/orient itself relative to the mobile robot's attachment point.\xa0 \n \n 為了驗證我們做的正確，我們拖動模型 Models/robots/mobile/KUKA Omnirob.ttm 進來，然後，我們選擇機器人模型，然後在移動平台上按住 Control 鍵並點擊其中一個附接點，然後單擊“組裝 Assembling/ 拆卸 disassemblin ”工具欄按鈕。我們的機器人應該正確地將自己放置在移動機器人的頂部： \n To verify that we did things right, we drag the model \xa0 Models/robots/mobile/KUKA Omnirob.ttm \xa0 into the scene. Then we select our robot model, then control-click one of the attachment points on the mobile platform, then click the \xa0 Assembling/disassembling toolbar button . Our robot should correctly place itself on top of the mobile robot: \n \xa0 \n 現在，我們可以向機器人添加其他項目，例如傳感器。 \n Now we could add additional items to our robot, such as sensors for instance.\xa0 \n 在某些時候，我們可能還希望將嵌入式腳本附加到我們的模型中，以便控制其行為或出於各種目的對其進行配置。在這種情況下，一定要了解項目如何從嵌入的腳本查看。我們還可以從\xa0 plugin 、\xa0 remote API \xa0client、 from a\xa0 ROS \xa0node、 \xa0 BlueZero \xa0node、 add-on ，control控制 /access 訪問 /interface 模型。確保我們已還原在機械手和夾具的安裝過程中所做的更改， 我們折疊機器人模型的層次樹，選擇模型的基礎，然後使用 [ 菜單欄 Menu bar-> 文件 File-> 將模型另存為 Save model as] 保存。 \n At some point we might also want to attach \xa0 embedded scripts \xa0 to our model, in order to control its behaviour or configure it for various purposes. In that case, make sure to understand \xa0 how object handles are accessed from embedded scripts . We can also control/access/interface our model from a \xa0 plugin , from a \xa0 remote API \xa0 client, from a \xa0 ROS \xa0 node, from a \xa0 BlueZero \xa0 node, or from an \xa0 add-on . \n Now we make sure we have reverted the changes done during robot and gripper attachment, we collapse the hierarchy tree of our robot model, select the base of our model, then save it with [Menu bar --> File --> Save model as...]. If we saved it in the \xa0 model \xa0 folder, then the model will be available in the \xa0 model brower . \n 40723102心得網址", 'tags': '', 'url': '40723102.html'}, {'title': '40723115', 'text': "Building the dynamic shapes If we want our robot to be dynamically enabled, i.e. react to collisions, fall, etc., then we need to create/configure the shapes appropriately: a shape can be: dynamic or static: a dynamic (or non-static) shape will fall and be influences by external forces/torques. A static (or non-dynamic) shape on the other hand, will stay in place, or follow the movement of its parent in the scene hierarchy. respondable or non-respondable: a respondable shape will cause a collision reaction with other respondable shapes. They (and/or) their collider, will be influenced in their movement if they are dynamic. On the other hand, non-respondable shapes will not compute a collision response if they collide with other shapes. Above two points are illustrated here. Respondable shapes should be as simple as possible, in order to allow for a fast and stable simulation. A physics engine will be able to simulate following 5 types of shapes with various degrees of speed and stability: Pure shapes: a pure shape will be stable and handled very efficiently by the physics engine. The draw-back is that pure shapes are limited in geometry: mostly cuboids, cylinders and spheres. If possible, use those for items that are in contact with other items for a longer time (e.g. the feet of a humanoid robot, the base of a serial manipulator, the fingers of a gripper, etc.). Pure shapes can be created with [Menu bar --> Add --> Primitive shape]. Pure compound shapes: a pure compound shape is a grouping of several pure shapes. It performs almost as well as pure shapes and shares similar properties. Pure compound shapes can be generated by grouping several pure shapes [Menu bar --> Edit --> Grouping/Merging --> Group selected shapes]. Convex shapes: a convex shape will be a little bit less stable and take a little bit more computation time when handled by the physics engine. It allows for a more general geometry (only requirement: it need to be convex) than pure shapes. If possible, use convex shapes for items that are sporadically in contact with other items (e.g. the various links of a robot). Convex shapes can be generated with [Menu bar --> Add --> Convex hull of selection] or with [Menu bar --> Edit --> Morph selection into convex shapes]. Compound convex shapes, or convex decomposed shapes: a convex decomposed shape is a grouping of several convex shapes. It performs almost as well as convex shapes and shares similar properties. Convex decomposed shapes can be generated by grouping several convex shapes [Menu bar --> Edit --> Grouping/Merging --> Group selected shapes], with [Menu bar --> Add --> Convex decomposition of selection...], or with [Menu bar --> Edit --> Morph selection into its convex decomposition...]. Random shapes: a random shape is a shape that is not convex nor pure. It generally has poor performance (calculation speed and stability). Avoid using random shapes as much as possible. So the order of preference would be: pure shapes, pure compound shapes, convex shapes, compound convex shapes, and finally random shapes. Make sure to also read this page. In case of the robot we want to build, we will make the base of the robot as a pure cylinder, and the other links as convex or convex decomposed shapes. We could use the dynamically enabled shapes also as the visible parts of the robot, but that would probably not look good enough. So instead, we will build for each visible shape we have created in the first part of the tutorial a dynamically enabled counterpart, which we will keep hidden: the hidden part will represent the dynamic model and be exclusively used by the physics engine, while the visible part will be used for visualization, but also for minimum distance calculations, proximity sensor detections, etc. We select object robot, copy-and-paste it into a new scene (in order to keep the original model intact) and start the triangle edit mode. If object robot was a compound shape, we would first have had to ungroup it ([Menu bar --> Edit --> Grouping/Merging --> Ungroup selected shapes]) then merge the individual shapes ([Menu bar --> Edit --> Grouping/Merging --> Merge selected shapes]) before being able to start the triangle edit mode. Now we select the few triangles that represent the power cable, and erase them. Then we select all triangles in that shape, and click Extract cylinder. We can now leave the edit mode and we have our base object represented as a pure cylinder: [Pure cylinder generation procedure, in the triangle edit mode] We rename the new shape (with a double-click on its name in the scene hierarchy) as robot_dyn, assign it to visibility layer 9, then copy it to the original scene. The rest of the links will be modelled as convex shapes, or compound convex shapes. We now select the first mobile link (i.e. object robot_link1) and generate a convex shape from it with [Menu bar --> Add --> Convex hull of selection]. We rename it to robot_link_dyn1 and assign it to visibility layer 9. When extracting the convex hull doesn't retain enough details of the original shape, then you could still manually extract several convex hulls from its composing elements, then group all the convex hulls with [Menu bar --> Edit --> Grouping/Merging --> Group selected shapes]. If that appears to be problematic or time consuming, then you can automatically extract a convex decomposed shape with [Menu bar --> Add --> Convex decomposition of selection...]: [Original shape, and convex shape pendant] [Original shape, and convex decomposed shape pendant] We now repeat the same procedure for all remaining robot links. Once that is done, we attach each visible shape to its corresponding invisible dynamic pendant. We do this by selecting first the visible shape, then via control-click selecting its dynamic pendant then [Menu bar --> Edit --> Make last selected object parent]. The same result can be achieved by dragging the visible shape onto its dynamic pendant in the scene hierarchy: [Visible shapes attached to their dynamic pendants] We still need to take care of a few things: first, since we want the dynamic shapes only visible to the physics engine, but not to the other calculation modules, we uncheck all object special properties for the dynamic shapes, in the object common properties. Then, we still have to configure the dynamic shapes as dynamic and respondable. We do this in the shape dynamics properties. Select first the base dynamic shape (i.e. robot_dyn), then check the Body is respondable item. Enable the first 4 Local respondable mask flags, and disable the last 4 Local respondable mask flags: it is important for consecutive respondable links not to collide with each other. For the first mobile dynamic link in our robot (i.e. robot_link_dyn1), we also enable the Body is respondable item, but this time we disable the first 4 Local respondable mask flags, and enable the last 4 Local respondable mask flags. We repeat the above procedure with all other dynamic links, while always alternating the Local respondable mask flags: once the model will be defined, consecutive dynamic shapes of the robot will not generate any collision response when interacting with each other. Try to always end up with a construction where the dynamic base of the robot, and the dynamic last link of the robot have only the first 4 Local respondable mask flags enabled, so that we can attach the robot to a mobile platform, or attach a gripper to the last dynamic link of the robot without dynamic collision interferences. Finally, we still need to tag our dynamic shapes as Body is dynamic. We do this also in the shape dynamics properties. We can then enter the mass and inertia tensor properties manually, or have those values automatically computed (recommended) by clicking Compute mass & inertia properties for selected convex shapes. Remember also this and that dynamic design considerations. This dynamic base of the robot is a special case: most of the time we want the base of the robot (i.e. robot_dyn) to be non-dynamic (i.e. static), otherwise, if used alone, the robot might fall during movement. But as soon as we attach the base of the robot to a mobile platform, we want the base to become dynamic (i.e. non-static). We do this by enabling the Set to dynamic if gets parent item, then disabling the Body is dynamic item. Now run the simulation: all dynamic shapes, except for the base of the robot, should fall. That attached visual shapes will follow their dynamic pendants. \n 建構動態形狀 如果想要讓我們的機器人啟用動態,換句話說對碰撞跌倒做出反應, 那麼我們需要適當地創建/配置形狀：形狀可以是： • 動態或靜態: 動態(或非靜態)，形狀會變形並受到外力或是扭矩的影響。 另一方面，靜態(或非靜態)行裝會保持不變，或在場景的層次結構中跟著母體做動 •合理和不合理:一個合理的形狀會與其他合理的形狀造成碰撞反應. 如果他們是動態的狀況下，他們將受到影響. 換句話說, 不合理的形狀與其他形狀發生碰撞，則不會產生碰撞反應。 以上說明的兩點。合理的形狀盡可能簡化，以實現快速且穩定的仿真。物理引擎將能夠以不同的速度和穩定性模擬以下5種類型的形狀： •純形狀: 純形狀在物理引擎是穩定且有效的運行， 但缺點是純形狀得幾何形狀受到限制:主要是長方體、圓柱體和球體。 如果可能的話，將其用於與其他物品接觸時間較長的物品（例如，人形機器人的腳，串行機械手的底座，抓手的手指等）。可以使用[菜單欄->添加->基本形狀]創建純形狀。 • 純複合形狀: 純複合形狀是幾個純形狀的組合。它的性能幾乎與純形狀一樣，並具有相似的特性。可以通過對幾個純形狀進行分組來生成純複合形狀[菜單欄->編輯->分組/合併->分組所選形狀]。 • 凸形狀: 當由物理引擎處理時，凸形的穩定性會降低一些，並且會花費更多的計算時間。與純形狀相比，它允許使用更通用的幾何形狀（僅要求：它必須是凸形的）。如果可能，將凸形用於偶爾與其他物品接觸的物品（例如，機器人的各個鏈接）。可以使用[菜單欄->添加->選擇的凸包]或[菜單欄->編輯->將選擇變形為凸形]生成凸形。 • 複合凸形狀或凸分解形狀：凸分解形狀是幾個凸形狀的組合。它的性能幾乎與凸形相同，並具有相似的特性。可以通過將多個凸形分組[菜單欄->編輯->分組/合併->分組選定的形狀]，並使用[菜單欄->添加->選擇的凸分解...]來生成凸分解形狀。 ]，或使用[菜單欄->編輯->將選擇變形到其凸分解...]。 • 不規則形狀: 不規則形狀是既非凸形也不是純淨的形狀。它通常具有較差的性能（計算速度和穩定性）。盡量避免使用隨機形狀。 因此，優先順序為：純形狀，純複合形狀，凸形，複合凸形，最後是隨機形狀。確保還閱讀此頁面。對於要構建的機器人，我們將其基座設為純圓柱體，將其他鏈接設為凸形或凸形分解形狀。 我們也可以將動態啟用的形狀用作機器人的可見部分，但是看起來可能不夠好。因此，相反，我們將為在本教程第一部分中創建的每個可見形狀構建一個動態啟用的副本，該副本將保持隱藏狀態：隱藏部分將代表動態模型，並由物理引擎專用，而可見部分將用於可視化，還用於最小距離計算，接近傳感器檢測等。 我們選擇對像機器人，將其複制並粘貼到新場景中（以保持原始模型不變），然後啟動三角形編輯模式。如果對像機器人是複合形狀，我們首先必須將其取消組合（[菜單欄->編輯->分組/合併->取消組合所選形狀]），然後合併各個形狀（[菜單欄->在啟動三角形編輯模式之前，請編輯->分組/合併->合併選定的形狀]）。現在，我們選擇代表電源線的幾個三角形，並將其刪除。然後我們選擇該形狀中的所有三角形，然後單擊“提取” 圓筒。現在我們可以離開編輯模式，我們的基礎對象表示為純圓柱體： 我們將新形狀重命名（在場景層次中雙擊其名稱）為robot_dyn，將其分配給可見性層9，然後將其複製到原始場景。其餘鏈接將建模為凸形或複合凸形。現在，我們選擇第一個移動鏈接（即對象robot_link1），並使用[菜單欄->添加->選擇的凸包]從中生成凸形。我們將其重命名為robot_link_dyn1並將其分配給可見性層9。當提取凸包並沒有保留足夠的原始形狀細節時，您仍然可以手動從其組成元素中提取多個凸包，然後將所有凸包與[菜單欄->編輯->分組/合併->對選定形狀進行分組]。如果這似乎有問題或很耗時，則可以使用[菜單欄->添加->選擇的凸分解...]自動提取凸分解的形狀： 現在，我們對所有剩餘的機器人鏈接重複相同的過程。完成後，我們將每個可見的形狀附加到其相應的不可見的動態吊墜上。為此，我們先選擇可見的形狀，然後按住Control鍵並單擊以選擇其動態吊墜，然後選擇[菜單欄->編輯->將最後選擇的對象設為父對象]。通過將可見形狀拖動到場景層次中的動態吊墜上，可以實現相同的結果： 我們仍然需要注意一些事項：首先，由於我們希望動態形狀僅對物理引擎可見，而對其他計算模塊不可見，因此在對象通用屬性中取消選中動態形狀的所有對象特殊屬性。 。 然後，我們仍然必須將動態形狀配置為動態且可響應的。我們在形狀動力學屬性中執行此操作。首先選擇基本動態形狀（即robot_dyn），然後檢查“主體是可響應的”項。啟用前四個“本地可響應掩碼”標誌，並禁用後四個“本地可響應掩碼”標誌：對於連續的可響應鏈接不要彼此衝突非常重要。對於我們機器人中的第一個移動動態鏈接（即robot_link_dyn1），我們還啟用了“身體可響應”項，但是這次我們禁用了前4個“本地可響應掩碼”標誌，並啟用了後4個“本地可響應掩碼”標誌。我們對所有其他動態鏈接重複上述過程，同時始終交替使用Local Responsible Mask標誌：一旦定義了模型，則連續的機器人動態形狀在彼此交互時不會產生任何碰撞響應。嘗試始終以這樣一種構造結束：機器人的動態基礎和機器人的動態最後一個鏈接僅啟用了前4個“本地可響應掩碼”標誌，以便我們可以將機器人附加到移動平台，或附加一個抓取器連接到機器人的最後一個動態鏈接，而沒有動態碰撞干擾。 最後，我們仍然需要將動態形狀標記為“身體是動態的”。我們也在形狀動力學屬性中執行此操作。然後，我們可以手動輸入質量和慣性張量屬性，或者通過單擊“計算選定凸形的質量和慣性屬性”來自動計算（推薦）那些值。還請記住這一點以及該動態設計注意事項。機器人的這種動態基座是一種特殊情況：大多數時候，我們希望機器人的基座（即robot_dyn）是非動態的（即靜態），否則，如果單獨使用，則機器人可能會在運動過程中掉落。但是，一旦我們將機器人的底座連接到移動平台上，我們就希望底座變得動態（即非靜態）。我們通過啟用“如果獲取父項時設置為動態”項，然後禁用“主體為動態”項來做到這一點。現在運行仿真：除了機器人的基座之外，所有動態形狀都應下降。附加的視覺形狀將跟隨其動態吊墜。 \n", 'tags': '', 'url': '40723115.html'}, {'title': '40723120', 'text': "Building a clean model tutorial \n 建立一個簡潔的模型教學 \n This tutorial will guide you step-by-step into building a clean simulation model, of a robot, or any other item. This is a very important topic, maybe the most important aspect, in order to have a nice looking, fast displaying, fast simulating and stable simulation model. \n 這個教學會一步一步的引導你去建造出一個簡潔可模擬模型、機器人，或任何其他項目。這是一個非常重要的主題，或許是最重要的方面‧為了有良好的外觀、迅速的展示、模擬，然後穩定的模擬模型。 \n To illustrate the model building process, we will be building following manipulator: \n 為了說明建造模型的過程，我們會建立一個機械手臂 : \n \n Building the visible shapes \n 建立可見的形狀 \n When building a new model, first, we handle only the visual aspect of it: the dynamic aspect (its undelying even more simplified/optimized model), joints, sensors, etc. will be handled at a later stage. \n 當建立新的模型時，首先，我們先處理模組大小規格 : 動態方面 ( 讓模型簡化 / 優化 ) ，支點，感應器 ….. 等等，之後會將處理。 \n We could now directly create primitive shapes in CoppeliaSim with [Menu bar --> Add --> Primitive shape --> ...]. When doing this, we have the option to create\xa0 pure shapes, or regular shapes . Pure shape will be optimized for dynamic interaction, and also directly be dynamically enabled (i.e. fall, collide, but this can be disabled at a later stage). Primitive shapes will be simple meshes, which might not contain enough details or geometric accuracy for our application. Our other option in that case would be to import a mesh from an external application. \n 我們可以直接在 CoppeliaSim 建立原始形狀 [Menu bar --> Add --> Primitive shape --> ...] 當這樣做時，我們可以選擇創建純粹的形狀或是有規格的形狀，純粹的形狀將會對動態的互動進行優化，爾且可以直接啟用動態 ( 例如 : 跌落、破狀，這些也可以在之後關掉 ) ，基本的形狀就是簡單得網格，對於我們的運用可能沒有足夠的細節或是幾何精度。在這種情況下，我們的可以選擇從外部應用程式導入網格。 \n When importing CAD data from an external application, the most important is to make sure that the CAD model is not too heavy, i.e. doesn't contain too many triangles. This requirement is important since a heavy model will be slow in display, and also slow down various calculation modules that might be used at a later stage (e.g. \xa0 minimum distance calculation , or \xa0 dynamics ). Following example is typically a no-go (even if, as we will see later, there are means to simplify the data within CoppeliaSim): \n \xa0 \n 從外部應用程式匯入 CAD 資料時，最重要的是要確保 CAD 的模型不會有太多複雜的面，例如 : 不要包含太多的三角形。此要求很重要，因為有太多複雜面的模型在顯示時會非常緩慢，還會減慢了之後可能使用的各種計算模塊 ( 例如 : 最小距離計算或是動態計算 ) ， 以下示例通常是不行的 ( 即使是下方的例子也有方法可以簡化 CoppeliaSim 中的數據 ) \n \n Above CAD data is very heavy: it contains many triangles (more than 47'000), which would be ok if we would just use a single instance of it in an empty scene. But most of the time you will want to simulate several instances of a same robot, attach various types of grippers, and maybe have those robots interact with other robots, devices, or the environment. In that case, a simulation scene can quickly become too slow. Generally, we recommend to model a robot with no more than a total of 20'000 triangles, but most of the time 5'000-10'000 triangles would just do fine as well. Remember: less is better, in almost every aspect. \n 關於 CAD 資料太大 : 這包含太多三角形 ( 超過 47000 個 ) ， 如果我們只在空場景中使用一個實例，那沒關係，但是大多數時候，你會想要模擬同一個機器人的多個實例、附加各種類型的爪子、或許也會讓那些機器人與其他機器人互動、還有其他設備或環境。在下面的例子，模擬場景可能快速變得緩慢，通常，我們建議對不超過 2 萬個三角形的機器人進行建模。大多數時用 5000~10000 個三角形比較好，記住 : 幾乎所有方面都是越少越好。 \n What makes above model so heavy? First, models that contain holes and small details will require much more triangular faces for a correct representation. So, if possible, try to remove all the holes, screws, the inside of objects, etc. from your original model data. If you have the original model data represented as parametric surfaces/objects, then it is most of the time a simple matter of selecting the items and deleting them (e.g. in Solidworks). The second important step is to export the original data with a limited precision: most CAD applications let you specify the level of details of exported meshes. It might also be important to export the objects in several steps, when the drawing consists of large and small objects; this is to avoid having large objects too precisely defined (too many triangles) and small objects too roughly defined (too few triangles): simply export large objects first (by adjusting the desired precision settings), then small objects (by adjusting up precision settings). \n 是什麼讓上述模型太大 ? 首先，有包含孔和小細節的模型將需要更多的三角形面才能正確顯示 ，所以可能的話，嘗試從原始模型中刪除所有孔，螺釘，物體內部物件等。如果原始模型顯示有參數化的曲面 / 物件，那麼在大多數情況下，選擇項目並刪除它們就很簡單了 ( 例如 : 在 Solidworks 中 ) 。第二個重要步驟是在有限的精度中導出原始資料 : 大多數 CAD 應用程序可讓您指定導出網格的詳細程度，當圖形包含大小物件時，分步導出物件也是很重要的 ; 這是為了避免大物件定義太精確 ( 太多三角形 ) 而小物件定義太粗糙 ( 太少三角形 ) ，先導出大型的物件 ( 通過所需的調整精度設置 ) 然後是小物件 ( 在調整精度設置 ) 。 \n \xa0CoppeliaSim supports currently following CAD data formats:\xa0 OBJ , \xa0 STL , \xa0 DXF , \xa0 3DS \xa0 (Windows only), and \xa0 Collada . \xa0 URDF \xa0 is also supported, but not mentionned here since it is not a pure mesh-based file format. \n CoppeliaSim 支援當前以下 CAD 數據格式 :OBJ 、 STL 、 DXF 、 3DS( 限定 Windows) 、 Collada 。還有 URDF 也是支援的，但是這裡沒有提到，因為它不是基於網格的純文件格式。 \n Now suppose that we have applied all possible simplifications as described in previous section. We might still end-up with a too heavy mesh after import: \n 現在假設我們已經按照上一節中的描述使用了所有可能的簡化，我們可能最終在導入後仍然會留下太多的網格 : \n \n You can notice that the whole robot was imported as a single mesh. We will see later how to divide it appropriately. Notice also the wrong orientation of the imported mesh: best is to keep the orientation as it is, until the whole model was built, since, if at a later stage we want to import other items that are related to that same robot, they will automatically have the correct position/orientation relative to the original mesh. \n 你可能注意到整個機器人是作為單個網格導入的，之後我們將看到如何對它進行適當分開，還要注意導入的網格是否方向錯 : 建立完整模型之前，最好是保持原樣，因為，如果以後要導入與同一機器人相關的其他項目，它們將自動保有相對於原始網格的正確位置 / 方向。 \n At this stage, we have several functions at our disposal, to simplify the mesh: \n 在此階段，我們可以使用多種功能來簡化網格： \n \n \n Automatic mesh division: \xa0 allows to generate a new shape for all elements that are not linked together via a common edge. This does not always work for the selected mesh, but is always worth a try, since working on mesh elements gives us more control than if we had to work on all elements at the same time. The function can be accessed with [Menu bar --> Edit --> Grouping/Merging --> Divide selected shapes]. Sometimes, a mesh will be divided more than expected. In that case, simply merge elements that logically belong together (i.e. that will have the same visual attributes and that are part of the same link) back into one single shape ([Menu bar --> Edit -> Grouping/Merging --> Merge selected shapes]). \n Extract the convex hull: \xa0 allows to simplify the mesh by transforming it into a convex hull. The function can be accessed with [Menu bar --> Edit --> Morph selection into convex shapes]. \n Decimate the mesh: \xa0 allows to reduce the number of triangles contained in the mesh. The function can be accessed with [Menu bar --> Edit --> Decimate selected shape...]. \n Remove the inside of the mesh: \xa0 allows to simplify the mesh by removing its inside. This function is based on \xa0 vision sensors \xa0 and might give more or less satisfying results depending on the selected settings. The function can be accessed with [Menu bar --> Edit --> Extract inside of selected shape]. \n ‧ Automatic mesh division : 允許為所有元素生成新形狀，當他們沒有通過共同的邊緣鏈接在一起時，這個不是一直有用於選定的網格，但是值得一試，因為與必須同時處理所有元素相比，處理網格元素可以為我們提供更多的控制權。該功能可以通過 [Menu bar --> Edit --> Grouping/Merging --> Divide selected shapes] 。有時候，網格的劃分將超出預期。在這種情況下，只需合併邏輯上屬於一起的元素 ( 例如 : 具有相同的視覺屬性，並且是同一鏈接的一部分 ) 回到一個單一的形狀 ([Menu bar --> Edit -> Grouping/Merging --> Merge selected shapes]) \n ‧ Extract the convex hull: 通過將其轉換為凸包來簡化網格，該功能可以通過 [Menu bar --> Edit --> Morph selection into convex shapes]. \n ‧ Decimate the mesh: 允許減少網格中包含的三角形數量，該功能可以通過 [Menu bar --> Edit --> Decimate selected shape...] \n ‧ Remove the inside of the mesh: 允許通過刪除其內部來簡化網格。此功能基於視覺傳感器，並且可能會根據所選設置提供或多或少令人滿意的結果，該功能可以通過 [Menu bar --> Edit --> Extract inside of selected shape] \n There is no predefined order in which above functions can/should be applied (except for the first item in the list, which should always be tried first), it heavily depends on the geometry of the mesh we are trying to simplify. Following image illustrates above functions applied to the imported mesh (let's suppose the first item in the list didn't work for us): \n \n 上述的功能沒有定義應該使用的順序 ( 除列表中的第一項外，應始終先嘗試 ) ，在很大程度上取決於我們要簡化網格的幾何形狀，下圖說明了上述功能導入網格的應用 ( 假設列表中的第一項對我們不起作用 ): \n \n Notice how the convex hull doesn't help us at this stage. We decide to use the mesh decimation function first, and run the function twice in order to divide the number of triangles by a total of 50. Once that is done, we extract the inside of the simplified shape and discard it. We end-up with a mesh containing a total of 2'660 triangles (the original imported mesh contained more than 136'000 triangles!). The number of triangles/vertices a shape contains can be seen in the\xa0 shape geometry dialog . 2'660 triangles are extremely few triangles for a whole robot model, and the visual appearance might suffer a little bit from it. \n 請注意，凸包在現階段如何對我們沒有幫助。我們先決定使用網格的抽取功能，並將此功能運行兩次以至三角形的總數到 50 ，一旦完成，我們提取簡化形狀的內部並將其丟棄，我們最終得到一個總共 2'660 個三角形的網格 ( 原始導入的網格超過 136'000 個三角形 ) 。 整個模型包含的三角形 / 頂點的數量可以在形狀幾何對話框中看到， 2'660 個三角形對於整個機器人模型來說是很少的三角形，但是視覺外觀可能會因此受到一點影響。 \n At this stage we can start to divide the robot into separate links (remember, we currently have only a single shape for the whole robot). You can do this in two different ways: \n 在這一階段，我們可以開始將機器人劃分為單獨的鏈接 ( 請記住，我們目前整個機器人只有一個形狀 ) ，你可以通過兩種不同的方式執行此操作： \n \n \n Automatic mesh division: \xa0 this function, which was already described in previous section, will inspect the shape and generate a new shape for all elements that are not linked together via a common edge. This does not always work, but is always worth a try. The function can be accessed with [Menu bar --> Edit --> Grouping/merging --> Divide selected shapes]. \n Manual mesh division: \xa0 via the the \xa0 triangle edit mode , you can manually select the triangles than logically belong together, then click \xa0 Extract shape . This will generate a new shape in the scene. Delete the selected triangles after that operation. \n \n ‧ Automatic mesh division: 這個功能，上一節已經描述過了，將檢查形狀並為未通過公共邊鏈接在一起的所有元素生成新形狀，這並不總是有效， 但是值得一試，該功能可以通過 [Menu bar --> Edit --> Grouping/Merging --> Divide selected shapes] 。 \n ‧ Manual mesh division: 通過三角形編輯模式，您可以手動選擇邏輯上屬於三角形的三角形，點擊 Extract shape 。這將在場景中產生新的形狀，完成該操作後，刪除選定的三角形。 \n In the case of our mesh, method 1 worked fine: \n 在這個例子中我們的網格，方法 1 效果很好 : \n \n Now, we could further refine/simplify individual shapes. Sometimes also, a shape might look better if its convex hull is used instead. Othertimes, you will have to use several of above's described techniques iteratively, in order to obtain the desired result. Take for instance following mesh: \n \n \n 現在，我們可以進一步細化 / 簡化單個形狀，有時也可以使用凸包代替形狀，有時，您將不得不反複使用上述幾種技術，以獲得所需的結果。 以以下網格為例： \n \n The problem with above's shape is that we cannot simplify it nicely, because of the holes it contains. So we have to go the more complicated way via the\xa0 shape edit mode , where we can extract individual elements that logically belong to the same convex sub-entity. This process can take several iterations: we first extract 3 approximate convex elements. For now, we ignore the triangles that are part of the two holes. While editing a shape in the shape edit mode, it can be convenient to switch the \xa0 visibility layers , in order to see what is covered by other scene items. \n 上面形狀的問題是我們不能很好地簡化它，因為它包含孔。因此，我們必須通過形狀編輯模式採用更複雜的方法，在這裡我們可以提取在邏輯上屬於同一個凸子實體的單個元素。此過程可能需要多次重覆：首先我們提取 3 個近似凸元素。現在，我們忽略為兩個孔的一部分的三角形。在形狀編輯模式下編輯形狀時，切換可見性層會很方便，還有方便查看其他場景項目所涵蓋的內容。 \n \n We end up with a toal of three shapes, but two of them will need further improvement. Now we can erase the triangles that are part of the holes. Finally, we extract the convex hull individually for the 3 shapes, then merge them back together with [Menu bar --> Edit --> Grouping/Merging --> merge selected shapes]: \n 我們最終得到三種形狀，但是其中兩個將需要進一步改進。現在我們可以刪除作為孔的一部分的三角形。最後，我們分別提取 3 種形狀的凸包，然後將它們合併在一起 [Menu bar --> Edit --> Grouping/Merging --> merge selected shapes]: \n \n In CoppeliaSim, we can enable/disable edge display for each shape. We can also specify an angle that will be taken into account for the edge display. A similar parameter is the\xa0 shading angle , that dictates how facetted the shape will display. Those parameters, and a few others such as the shape \xa0 color , can be adjusted in the \xa0 shape properties . Remember that \xa0 shapes come in various flavours . In this tutorial we have only dealt with simple shapes up to now: a simple shape has a single set of visual attributes (i.e. one color, one shading angle, etc.). If you merge two shapes, then the result will be a simple shape. You can also group shapes, in which case, each shape will retain its visual attributes. \n 在 CoppeliaSim 中，我們可以啟用 / 禁用每種形狀的邊緣顯示。我們還可以指定邊緣顯示時要考慮的角度。相似的參數是陰影角，決定形狀如何顯示。那些參數，還有其他一些，例如形狀顏色 ，可以調整形狀屬性。請記住形狀各異。在本教程中，到目前為止，我們僅處理了簡單的形狀 : 一個簡單的形狀具有一組視覺屬性 ( 例如一種顏色，一種陰影角度等 ) 。如果合併兩個形狀，那麼結果將是一個簡單的形狀。您還可以對形狀進行分組，在這種情況下，每個形狀將保留其視覺屬性。 \n In next step, we can merge elements that logically belong together (if they are part of the same rigid element, and if they have the same visual attributes). Then we change the visual attributes of the various elements. The easiest ist to adjust a few shapes that have different colors and visual attributes, and if we name the color with a specific string, we can later easily programmatically change that color, also if the shape is part of a compound shape. Then, we select all the shapes that have the same visual attributes, then control-select the shape that was already adjusted, then click \xa0 Apply to selection , once for the \xa0 Colors , once for the \xa0 other properties , in the \xa0 shape properties : this transfers all visual attributes to the selected shapes (including the color name if you provided one). We end up with 17 individual shapes: \n 在下一步中，我們可以合併在邏輯上屬於一樣的元素 ( 如果它們是同一剛性元素的一部分，並且它們具有相同的視覺屬性 ) 。然後我們更改各種元素的視覺屬性。最簡單的方法是調整一些具有不同顏色和視覺屬性的形狀，如果我們用特定的字符串命名顏色，我們以後可以輕鬆地以編程方式更改該顏色，如果形狀是複合形狀的一部分，也是如此。然後，我們選擇具有相同視覺屬性的所有形狀，然後控制選擇已調整的形狀，然後單擊 Apply to selection ，一次用於顏色，一次用於其他屬性，在形狀屬性中：這會將所有視覺屬性轉移到所選形狀 ( 包括顏色名稱，如果提供的話 ) 。 我們最終得到 17 個單獨的形狀： \n \n Now we can group the shapes that are part of the same link with [Menu bar --> Edit --> Grouping/merging -> Group selected shapes]. We end up with 7 shapes: the base of the robot (or base of the robot's hierarchy tree), and 6 mobile links. It is also important to correctly name your objects: you we do this with a double-click on the object name in the\xa0 scene hierarchy . The base should always be the robot or model name, and the other objects should always contain the base object name, like: \xa0 robot \xa0 (base), \xa0 robot_link1 , \xa0 robot_proximitySensor , etc. By defaut, shapes will be assigned to visibility layer 1, but can be changed in the \xa0 object common properties . By default, only \xa0 visibility layers 1-8 are activated for the scene . We now have following (the model \xa0 ResizableFloor_5_25 \xa0 was temporarily made invisible in the \xa0 model properties dialog ): \n 現在我們可以將屬於同一鏈接的形狀分組 [Menu bar --> Edit --> Grouping/merging -> Group selected shapes] \xa0 我們最終得到 7 種形狀機器人的基底 ( 或機器人層次結構樹的基礎 ) ，和 6 個移動鏈接。正確命名物件也很重要 : 您可以通過雙擊場景層次中的對象名稱來執行此操作。基礎應該始終是機器人或型號名稱，其他對象應始終包含基礎對象名稱，例如： robot(base) ， robot_link1 ， robot_proximitySensor 等。默認情況下，形狀將分配給可見性圖層 1 ，但是可以更改對象的通用屬性。默認情況下，僅激活場景的可見性層 1-8 。我們現在有以下 ( 模型 ResizableFloor_5_25 在模型屬性對話框中暫時不可見 ): \n \n \n When a shape is created or modified, CoppeliaSim will automatically set its reference frame position and orientation. A shape's reference frame will always be positioned at the shape's geometric center. The frame orientation will be selected so that the shape's bounding box remains as small as possible. This does not always look nice, but we can always reorient a shape's reference frame at any time. We now reorient the reference frames of all our created shapes with [Menu bar --> Edit --> Reorient bounding box --> with reference frame of world]. You have more options to reorient a reference frame in the\xa0 shape geometry dialog . \n 創建或修改形狀時， CoppeliaSim 將自動設置其參考框架的位置和方向，形狀的參考框架將始終位於形狀的幾何中心。將選擇框架方向，以便形狀的邊界框保持盡可能小。這並不是一直看起來不錯，但是我們總是可以隨時調整形狀的參考框架的方向。現在，我們使用以下命令重新調整所有已創建形狀的參考框架的方向： [Menu bar --> Edit --> Reorient bounding box --> with reference frame of world] 。您有更多選項可以在形狀幾何對話框中重新定向參考框架。 \n", 'tags': '', 'url': '40723120.html'}, {'title': '40723146', 'text': "建立節點 \n 現在，我們將關注節點和馬達，大多數時候，我們知道每個關節的準確的位置和方向，在這種情況下，我們只需使用按下 [ 菜單欄 -> 添加 -> 關節 -> ...] 來添加關節，然後我們可以使用“位置”欄和“方向”欄更改其位置和方向。在其他情況下，我們只有 \xa0D-H 矩陣（即 D-H ）參數，在這種情況下，我們可以透過模型瀏覽器中位於 Models / tools / Denavit-Hartenberg joint creator.ttm 中的工具模型來構建關節， \n 但在其他的狀況下，我們不清楚關節位置和他的方向。所以，我們需要從導入的網格中提取它們。讓我們假設這是我們目前的情況。不用處理修改過的，更近似的網格，而是打開一個新情景，然後再次導入原始 CAD 數據。大多數時候，我們可以從最初的網格中提取網格或它的基本形狀，第一步是細分原始網格，如果不起作用，我們將經由三角形編輯模式來進行操作。讓我們假設我們現在可以細分原始的網格，我們現在可以觀察更小的物件，我們正在尋找迴轉形狀，它可以用作在其位置創建節點並以相同方向來參考。首先，刪除所有不需要的物件，有時在多個打開的場景中工作也很有幫助，它可以便於可視化和操作，在我們的案例中，我們首先注意機器人的底座：它包含一個圓柱體，該圓柱體的第一個節點的位置正確。在三角形編輯模式下，我們有： \n \n [Robot base: normal and triangle edit mode visualization] \n 我們通過頁面選擇器工具欄按鈕來更改攝影機的視角，為了從側面來查看物件。 fit-to-view 工具欄按鈕可以派上用場，可用來正確地框束物件的版本。然後，我們切換到 vertex edit 模式，並選擇屬於圓盤上的所有頂點。記住我們可以通過打開 / 關閉某些層，我們可以隱藏場景中的其他物件。然後，我們切換回三角形編輯模式： \n \n [Selected upper disc, vertex edit mode (1 & 2), triangle edit mode (3)] \n 現在，我們單擊“提取圓柱體”（在這種情況下，“提取形狀”也將起作用），這只是在場景中創建了圓柱體形狀，而這個場景是根據所選定的三角形我們離開編輯模式並放棄修改物件，現在我們新增一個旋轉節點， [ 菜單欄 -> 新增 -> 節點 -> 旋轉 ] ，然後讓它保持被選擇的狀態，並控制提取圓柱體的形狀在位置框的“位置”選項上，我們點擊“ Apply to selection ( 應用於選擇 ) ”，這基本上將圓柱體的 x / y / z 的位置複製到節點，現在兩者的位置都相同。在 [ 方向 ] 選項上，我們也點擊“ Apply to selection( 應用於選擇 ) ”：現在，我們選擇的物件方向也變成相同，有些時候，我們將需要圍繞其自身的參考範圍的旋轉節點增加約 \xa0 90/180 度，以獲得正確的方向或旋轉方向，如果需要，我們可以在該對話框的 [ 旋轉 ] 選項上執行此操作（在這種情況下，請不要忘記點擊“ Own frame( 自有框架 ) 按鈕 \n \n [Joint in correct location, with the correct orientation] \n 現在我們將節點複製回原始場景並保存 ( 不要忘記定期存檔你的資料，復原 / 重做功能非常有用，但不能保護你免於其他災難的影響 ) \n 我們對機器人的所有節點都重複上面的過程，然後重新命名他們，我們還將所有節點和他們的屬性稍長一點，讓我們方便查看所有關節 \n 透過默認，將節點分配於可見圖層 2 ，但可以在物件的公共屬性中對其進行修改， \n 現在，我們將所有節點分配給可見圖層 10 ，然後為場景臨時啟用可見圖層 10 ，以使這些節點也可視化 \n （默認情況下，僅激活場景的可見圖層 1-8 ），這就是我們到目前為止的結果（模型 ResizableFloor_5_25 模型在模型屬性對話框中暫時不可見）： \n \n [Joints in correct configuration] \n 到這裡，我們可以開始建構模型層次的結構並完成它的定義，但是，如果我們想要可以動態啟用 OPUR 機器人，則還有一個額外的步驟 \n 重點整理 \n 建立節點 Building the joints --------------------------------------------------------------- 知道每個關節的準確的位置和方向的情況 know the exact position and orientation of each of the joints 1.[菜單欄->添加->節點-> ...]來添加節點 add the joints with [Menu bar --> Add --> Joints --> ...] \n 2.可以使用“位置”欄和“方向”欄更改其位置和方向 we can change their position and orientation with the position dialog and orientation dialog. 3.透過模型瀏覽器中位於Models / tools / Denavit-Hartenberg joint creator.ttm中的工具模型來構建關節每個關節的準確的位置和方向 we can build our joints via the tool model located in Models/tools/Denavit-Hartenberg joint creator.ttm, in the model browser. Othertimes, we have no information about the joint locations and orientations --------------------------------------------------------------- 不知道每個關節的準確的位置和方向的情況 we have no information about the joint locations and orientations \n 1.打開一個新情景，然後再次導入原始CAD數據 we open a new scene, and import the original CAD data again \n 2.細分原始網格，如果不起作用，我們將經由三角形編輯模式來進行操作。 The first step is to subdivide the original mesh 2-1.讓我們假設我們現在可以細分原始的網格 Let's suppose that we could divide the original mesh \n 3.刪除所有不需要的物件(只留下需要的零件 此段無翻譯) remove all objects that are not needed 3-1.通過頁面選擇器工具欄按鈕來更改攝影機的視角 We change the camera view via the page selector toolbar button 3-2.為了從側面來查看物件。fit-to-view工具欄按鈕可以派上用場，可用來正確地框束物件的版本 The fit-to-view toolbar button can come in handy to correctly frame the object in edition 3-3.然後，我們切換到vertex edit模式，並選擇屬於圓盤上的所有頂點。記住我們可以通過打開/關閉某些層，我們可以隱藏場景中的其他物件。 Then we switch to the vertex edit mode and select all vertices that belong to the upper disc. Remember that by switching some layers on/off, \n 4.點擊“提取圓柱體” we click Extract cylinder 4-1.我們離開編輯模式並放棄修改物件 We leave the edit mode and discard the changes 4-2.新增一個旋轉節點，[菜單欄->新增->節點->旋轉]，然後讓它保持被選擇的狀態， we add a revolute joint with [Menu bar --> Add --> Joint --> Revolute], keep it selected 4-3.並控制提取圓柱體的形狀在位置框的[位置]選項上，我們點擊“Apply to selection (應用於選擇)” In the position dialog, on the position tab, we click Apply to selection 4-4.在[方向]選項上，我們也點擊“Apply to selection(應用於選擇)” In the orientation dialog, on the orientation tab, we also click Apply to selection: P.S:有些時候，我們將需要圍繞其自身的參考範圍的旋轉節點增加約 90/180度，以獲得正確的方向或旋轉方向 Sometimes, we will need to additionally rotate the joint about 90/180 degrees around its own reference frame in order to obtain the correct orientation or rotation direction \n 5. 在預設，節點分配於可見圖層2，但可以在物件的公共屬性中對其進行修改 By defaut, joints will be assigned to visibility layer 2, 5-1.將所有節點分配給可見圖層10，然後為場景臨時啟用可見圖層10（默認情況下，僅激活場景的可見圖層1-8） We assign now all joints to visibility layer 10, then temporarily enable visibility layer 10 for the scene to also visualize those joints (by default, only visibility layers 1-8 are activated for the scene).", 'tags': '', 'url': '40723146.html'}]};